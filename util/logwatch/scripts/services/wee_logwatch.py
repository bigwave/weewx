#!/usr/bin/python3
#
#    Copyright (c) 2009-2020 Tom Keffer <tkeffer@gmail.com>
#
#    See the file LICENSE.txt for your full rights.
#
"""A Python based logwatch script to process WeeWX logs.

Description:

    This script has been will analyse and report on WeeWX log entries as a plug
    in module to the logwatch monitoring system. The script distributed as part
    of the WeeWX package is aware of log entries generated by the WeeWX code
    base only. The script can be extended to analyse and report on WeeWX log
    entries generated by WeeWX extensions and add-ons.

    As well as being used by logwatch the script can also be executed directly
    with a log or other text file as the source. Whilst the power of the
    logwatch monitoring system is not available when this script is run
    directly, running the script directly is useful when extending the script
    to process log entries from WeeWX extensions and add-ons.

Compatibility:
    This script can process log entries from WeeWX 4.0 and later. WeeWX 3.x log
    entries can be processed but will likely result in many unmatched lines
    being reported.

Operation:

    Class WeeWXLogwatchEngine manages the analysis and reporting of the log
    entries. The actual processing and report generation is performed by one or
    more object based on class LogwatchProcessor. Class WeeWXLogwatchProcessor
    is based on class LogwatchProcessor and processes and reports on all log
    entries produced by the WeeWX code base. Additional user defined classes
    based on class LogwatchProcessor can be included in /home/weewx/logwatch or
    /etc/weewx/logwatch to include the processing of log entries from
    extensions/add-ons.

    Each processor object uses a config dict that defines the regular
    expressions used for analysing the log entries and the report
    layout/content. The regexs can be broken down into:

    - The ignore list, a list of regexs that match log entries that will be ignored.
    - Increments, regexs for which a match will result in a variable being incremented by one.
    - Sums, regexs for which a match will capture a number that will be added to a running total.
    - Itemised, regexs for which a match will capture one or more pieces of data from the log entry.

    The report layout/content config can be broken down into:

    - Summary counts, a simple tabular display of a label followed by a number,
      data is typically obtained from the Increments or Sums regexs
    - Itemised reports, a hybrid layout that by default includes summary type contents followed by associated log entries

    The script relies on two classes, class WeeWXLogwatchEngine and class
    LogwatchProcessor, and a config file. Class WeeWXLogwatchEngine controls the
    ingestion of log entries and generation of the WeeWX logwatch report
    through one or more objects based on class LogwatchProcessor.
    Class Logwatch filter ingests log lines and contributes to the WeeWX
    logwatch report for log lines that are in its vocabulary. For example, one
    LogwatchProcessor object may know how to recognise, interpret and report on
    log entries from a standard WeeWX install, another LogwatchProcessor object
    may know how to recognise, interpret and report on log entries from the
    Forecasting extension and yet another object could be used to handle the
    cmon extension log entries. In this was the WeeWX logwatch script can be
    extended to handle any log entries generated by a customised WeeWX
    installation.

    The WeeWX logwatch script is complete with everything needed to analyse and
    report on the WeeWX log entries generated by a default WeeWX install but can be
    extended via the WeeWX logwatch config file. Amongst other things, the WeeWX
    logwatch config file can be used to alter existing or define new regular
    expressions used for analysing log file entries as well as to alter existing
    or define new report segments.

    The WeeWX logwatch script is structured such that

    The logwatch filers rely on the known structure of the log entries and use
    regular expressions to search log entry lines for matching text. Regular
    expressions can be constructed in a manner to extract counts or other data
    for use in reports.

Extending the WeeWX logwatch script:


"""
# TODO. Changes to WeeWX code
# TODO. manager.py better log entry for lines 883 and 884
# TODO. manager.py better log entry for lines 1032 and 1033
# TODO. reportengine.py maybe change format of line 173 output
# TODO. reportengine.py maybe change format of line 189 output

# TODO. Better capture
# TODO. 'Errors' ingestion needs to capture match groups
# TODO. Get obs outside qc limits
# TODO. restx_db_error should capture protocol name and error
# TODO. restx_upload_errors should capture protocol name and error
# TODO. restx_bad_cert_wait should capture protocol name and error
# TODO. restx_unexpect_exception should capture protocol name and error
# TODO. restx_upload_attempt_fail should capture protocol name and error
# TODO. restx_upload_attempt_fail_exception should capture protocol name and error
# TODO. restx_bad_server should capture protocol name and error
# TODO. restx_connection_error_attempt should capture protocol name and error
# TODO. restx_socket_error_attempt should capture protocol name and error
# TODO. restx_response_exception should capture protocol name and error
# TODO. restx_missing_config should capture protocol name and error
# TODO. restx_missing_option should capture protocol name and error

# TODO. Reporting
# TODO. need custom report method for rsync
# TODO. ftp report needs checking to make sure all data is used where relevant
# current to commit eb4d4e1dc05d5d064a7313b0607f196cd4a0a48f

# Python imports
from __future__ import absolute_import
from __future__ import print_function

import optparse
import os
import re
import sys
import time

from configobj import ConfigObj

# WeeWX logwatch script version
WEEWX_LOGWATCH_VERSION = "0.1.0"


WEEWX_LOGWATCH_CONFIG_DEFAULT = {
    'ingest': {
        'ignore': ["Starting weewx weather system",
                   "Stopping weewx weather system: weewx.",
                   "Reloading weewx weather system: weewx.",
                   "__main__: Initializing weewx version",
                   "__main__: Using Python",
                   "__main__: Platform",
                   "__main__: Locale is",
                   "__main__: Waiting for sane time",
                   "__main__: PID file is ",
                   "__main__: Using configuration file",
                   "__main__: Debug is",
                   "__main__: Initializing engine",
                   "__main__: Starting up weewx version",
                   "__main__: [ *]+  Waiting \d+ (seconds|minutes) then retrying",
                   "__main__: retrying",
                   "__main__: [ *]+ Exiting",
                   "__main__: Received signal HUP. Initiating restart",
                   "__main__: Terminating weewx version",
                   "weewx\.engine: Loading station type",
                   "weewx\.engine: No services in service group",
                   "weewx\.engine: Loading service",
                   "weewx\.engine: Finished loading service",
                   "weewx\.engine: Starting main packet loop",
                   "weewx\.engine: Main loop exiting\. Shutting engine down",
                   "weewx\.engine: StdConvert target unit is",
                   "weewx\.engine: No calibration information in config file\. Ignored",
                   "weewx\.engine: Archive will use data binding",
                   "weewx\.engine: Record generation will be attempted in",
                   "weewx\.engine: Using archive interval of",
                   "weewx\.engine: Use LOOP data in hi/low calculations",
                   "weewx\.engine: Using binding",
                   "weewx\.engine: No catchup specified",
                   "weewx\.engine: Station does not support setting the time",
                   "weewx\.engine: Station does not support reading the time",
                   "weewx\.engine: Shutting down StdReport thread",
                   "weewx\.engine: StdReport thread has been terminated",
                   "weewx\.cheetahgenerator: Using search list",
                   "weewx\.cheetahgenerator: Skip ",
                   "weewx\.imagegenerator: Skip '",
                   "weewx\.manager: Created and initialized table",
                   "weewx\.manager: Daily summary version is",
                   "weewx\.manager: Created daily summary tables",
                   "weewx\.manager: Starting backfill of daily summaries",
                   "weewx\.manager: Processed \d+ records to backfill",
                   "weewx\.manager: Daily summaries up to date",
                   "weewx\.reportengine: Running reports for time",
                   "weewx\.reportengine: Running reports for latest time in the database",
                   "weewx\.reportengine: Report '[a-zA-Z0-9-_]+' not enabled. Skipping.",
                   "weewx\.reportengine: Running report '",
                   "weewx\.reportengine: No generators specified for report",
                   "weewx\.reportengine: Found configuration file",
                   "weewx\.reportengine: ftpgenerator: FTP upload not requested. Skipped.",
                   "weewx\.reportengine: rsyncgenerator: Rsync upload not requested. Skipped.",
                   "weewx\.database: maxwindspeed: This is a dry run.",
                   "weewx\.database: maxwindspeed: Using database binding",
                   "weewx\.database: maxwindspeed: Database transactions will use",
                   "weewx\.database: maxwindspeed: Applying",
                   "weewx\.database: maxwindspeed: This was a dry run.",
                   "weewx\.database: intervalweighting: This is a dry run.",
                   "weewx\.database: intervalweighting: Using database binding",
                   "weewx\.database: intervalweighting: Database transactions",
                   "weewx\.database: intervalweighting: Multiple distinct 'interval'",
                   "weewx\.database: intervalweighting: .+ will be applied by dropping",
                   "weewx\.database: intervalweighting: .+ has already been applied",
                   "weewx\.database: intervalweighting: Applying ",
                   "weewx\.database: intervalweighting: Calculated weighting",
                   "weewx\.database: intervalweighting: This was a dry run",
                   "weewx\.database: intervalweighting: .+ has already been applied",
                   "weewx\.database: intervalweighting: Checking table",
                   "weewx\.database: intervalweighting: Successfully checked",
                   "weewx\.database: intervalweighting: Processed .+ consisting of .+ would have been updated",
                   "weewx\.restx: Shut down .+ thread",
                   "weewx\.restx: ([^:]*): record .+ is stale",
                   "weewx\.restx: wait interval [()0-9<]+ has not passed for record",
                   "weewx\.restx: WU essentials:",
                   "weewx\.restx: Wunderground-PWS: Data for station",
                   "weewx\.restx: Wunderground-RF: Data for station",
                   "weewx\.restx: Raw packet:",
                   "weewx\.restx: Cached packet:",
                   "weewx\.restx: PWSWeather: Data for station",
                   "weewx\.restx: WOW: Data for station",
                   "weewx\.restx: Ambient: url: ",
                   "weewx\.restx: WOW: url: ",
                   "weewx\.restx: CWOP: Data for station",
                   "weewx\.restx: CWOP: packet: ",
                   "weewx\.restx: ([^:]*): Connected to server",
                   "weewx\.restx: StationRegistry: Registration not requested.",
                   "weewx\.restx: StationRegistry: Station will be registered.",
                   "weewx\.restx: AWEKAS: Data will be uploaded for user",
                   "weewx\.restx: AWEKAS: url: ",
                   "weewx\.restx: .+: Posting not enabled",
                   "weewx\.wxservices: The following values will be calculated:",
                   "weewx\.wxservices: The following algorithms will be used for calculations:",
                   "weeutil\.ftpupload: Attempting secure connection to",
                   "weeutil\.ftpupload: Attempting connection to",
                   "weeutil\.ftpupload: Secure data connection to",
                   "weeutil\.ftpupload: Connected to",
                   "weeutil\.ftpupload: Made directory",
                   "weeutil\.rsyncupload: rsyncupload: cmd:",
                   "weeutil\.rsyncupload: rsync executed in",
                   "weewx\.drivers\.vantage: Gentle wake up of console successful",
                   "weewx\.drivers\.vantage: Rude wake up of console successful",
                   "weewx\.drivers\.vantage: Unable to wake up console\.\.\.",
                   "weewx\.drivers\.vantage: Opened up serial port",
                   "weewx\.drivers\.vantage: Opened up ethernet host",
                   "weewx\.drivers\.vantage: Driver version is",
                   "weewx\.drivers\.vantage: Hardware name:",
                   "weewx\.drivers\.vantage: Requesting \d+ LOOP packets",
                   "weewx\.drivers\.vantage: Getting archive packets since",
                   "weewx\.drivers\.vantage: Getting all archive packets",
                   "weewx\.drivers\.vantage: Retrieving \d+ page\(s\); starting index=",
                   "weewx\.drivers\.vantage: Empty record page",
                   "weewx\.drivers\.vantage: DMPAFT complete: page timestamp [a-zA-Z0-9() :-]+ less than final timestamp",
                   "weewx\.drivers\.vantage: Catch up complete",
                   "weewx\.drivers\.vantage: Dumping all records",
                   "weewx\.drivers\.vantage: Starting logger summary",
                   "weewx\.drivers\.vantage: Vantage: Finished logger summary",
                   "weewx\.drivers\.vantage: Hardware type is",
                   "weewx\.drivers\.vantage: ISS ID is",
                   "weewx\.drivers\.fousb: got rainfall of",
                   "weewx\.drivers\.fousb: Power off port ",
                   "weewx\.drivers\.fousb: Power on port ",
                   "weewx\.drivers\.fousb: Waiting 30 seconds for station to power down",
                   "weewx\.drivers\.fousb: Waiting 60 seconds for station to power up",
                   "weewx\.drivers\.fousb: driver version is",
                   "weewx\.drivers\.fousb: power cycling enabled for port",
                   "weewx\.drivers\.fousb: polling mode is",
                   "weewx\.drivers\.fousb: polling interval is",
                   "weewx\.drivers\.fousb: found station on USB bus=",
                   "weewx\.drivers\.fousb: found \d+ archive records",
                   "weewx\.drivers\.fousb: returning archive record",
                   "weewx\.drivers\.fousb: get \d+ records since",
                   "weewx\.drivers\.fousb: synchronising to the weather station \(quality=",
                   "weewx\.drivers\.fousb: packet timestamp is",
                   "weewx\.drivers\.fousb: log timestamp is",
                   "weewx\.drivers\.fousb: delay ",
                   "weewx\.drivers\.fousb: status ",
                   "weewx\.drivers\.fousb: new data",
                   "weewx\.drivers\.fousb: live synchronised",
                   "weewx\.drivers\.fousb: new ptr: ",
                   "weewx\.drivers\.fousb: log synchronised",
                   "weewx\.drivers\.fousb: log extended",
                   "weewx\.drivers\.fousb: avoid ",
                   "weewx\.drivers\.fousb: waiting for ack",
                   "weewx\.drivers\.acurite: driver version is",
                   "weewx\.drivers\.acurite: R2 will be decoded using sensor constants",
                   "weewx\.drivers\.acurite: R2 bounds on constants will be ignored",
                   "weewx\.drivers\.acurite: R3 data will be attempted",
                   "weewx\.drivers\.acurite: R1: ",
                   "weewx\.drivers\.acurite: R2: ",
                   "weewx\.drivers\.acurite: R3: ",
                   "weewx\.drivers\.acurite: next read in ",
                   "weewx\.drivers\.acurite: Found station at bus=",
                   "weewx\.drivers\.cc3000: Driver version is",
                   "weewx\.drivers\.cc3000: Using serial port",
                   "weewx\.drivers\.cc3000: Polling interval is",
                   "weewx\.drivers\.cc3000: Using \S+ time for loop packets",
                   "weewx\.drivers\.cc3000: Sensor map is",
                   "weewx\.drivers\.cc3000: Clear logger at",
                   "weewx\.drivers\.cc3000: Firmware:",
                   "weewx\.drivers\.cc3000: Archive interval:",
                   "weewx\.drivers\.cc3000: Header:",
                   "weewx\.drivers\.cc3000: Units:",
                   "weewx\.drivers\.cc3000: Channel:",
                   "weewx\.drivers\.cc3000: Charger status:",
                   "weewx\.drivers\.cc3000: Memory:",
                   "weewx\.drivers\.cc3000: now: [\d,.]+, polling_interval:",
                   "weewx\.drivers\.cc3000: Next polling event in",
                   "weewx\.drivers\.cc3000: Values:",
                   "weewx\.drivers\.cc3000: Parsed:",
                   "weewx\.drivers\.cc3000: No rain in packet:",
                   "weewx\.drivers\.cc3000: Packet:",
                   "weewx\.drivers\.cc3000: No data from sensors",
                   "weewx\.drivers\.cc3000: Logger is at \d+ records",
                   "weewx\.drivers\.cc3000: GenStartupRecords: since_ts=",
                   "weewx\.drivers\.cc3000: Downloading new records \(if any\)",
                   "weewx\.drivers\.cc3000: No rain in record:",
                   "weewx\.drivers\.cc3000: Downloaded \d+ new records",
                   "weewx\.drivers\.cc3000: Found checksum at",
                   "weewx\.drivers\.cc3000: Calculated checksum",
                   "weewx\.drivers\.cc3000: Open serial port",
                   "weewx\.drivers\.cc3000: Close serial port",
                   "weewx\.drivers\.cc3000: Write: '",
                   "weewx\.drivers\.cc3000: Read: '",
                   "weewx\.drivers\.cc3000: Flush input buffer",
                   "weewx\.drivers\.cc3000: Flush output buffer",
                   "weewx\.drivers\.cc3000: \S+: The resetting of timeout to \d+ took",
                   "weewx\.drivers\.cc3000: \S+: Accepting empty string as cmd echo.",
                   "weewx\.drivers\.cc3000: \S+: times: [0-9. ]+",
                   "weewx\.drivers\.cc3000: \S+: Retry worked.  Total tries:",
                   "weewx\.drivers\.cc3000: Get firmware version",
                   "weewx\.drivers\.cc3000: Set echo to",
                   "weewx\.drivers\.cc3000: Get header",
                   "weewx\.drivers\.cc3000: Get time",
                   "weewx\.drivers\.cc3000: Get daylight saving",
                   "weewx\.drivers\.cc3000: Get units",
                   "weewx\.drivers\.cc3000: Get logging interval",
                   "weewx\.drivers\.cc3000: Get channel",
                   "weewx\.drivers\.cc3000: Get charger",
                   "weewx\.drivers\.cc3000: Get baro",
                   "weewx\.drivers\.cc3000: Get memory status",
                   "weewx\.drivers\.cc3000: Get max values",
                   "weewx\.drivers\.cc3000: Get min values",
                   "weewx\.drivers\.cc3000: Clear memory",
                   "weewx\.drivers\.cc3000: Get rain total",
                   "weewx\.drivers\.cc3000: gen_records_since_ts:",
                   "weewx\.drivers\.cc3000: gen_records\(\d+\)",
                   "weewx\.drivers\.cc3000: gen_records: Requested \d+ latest of \d+ records.",
                   "weewx\.drivers\.cc3000: DOWNLOAD",
                   "weewx\.drivers\.cc3000: Reading all records into memory.  This could take some time.",
                   "weewx\.drivers\.cc3000: Reading \d+ records into memory.",
                   "weewx\.drivers\.cc3000: Finished reading \d+ records.",
                   "weewx\.drivers\.cc3000: Downloaded \d+ records",
                   "weewx\.drivers\.te923: driver version is",
                   "weewx\.drivers\.te923: polling interval is",
                   "weewx\.drivers\.te923: sensor map is",
                   "weewx\.drivers\.te923: logger capacity",
                   "weewx\.drivers\.te923: station time is",
                   "weewx\.drivers\.te923: reading records from logger since",
                   "weewx\.drivers\.te923: read \d+ records from logger",
                   "weewx\.drivers\.te923: TH\d+  ",
                   "weewx\.drivers\.te923: UVX  ",
                   "weewx\.drivers\.te923: PRS  ",
                   "weewx\.drivers\.te923: WGS  ",
                   "weewx\.drivers\.te923: WSP  ",
                   "weewx\.drivers\.te923: WDR  ",
                   "weewx\.drivers\.te923: RAIN ",
                   "weewx\.drivers\.te923: WCL  ",
                   "weewx\.drivers\.te923: STT  ",
                   "weewx\.drivers\.te923: Found device on USB bus",
                   "weewx\.drivers\.te923: write: ",
                   "weewx\.drivers\.te923: read: ",
                   "weewx\.drivers\.te923: Waiting \d+ seconds before retry",
                   "weewx\.drivers\.te923: MEM  BUF[1]=",
                   "weewx\.drivers\.te923: detected [a-z]+ memory size",
                   "weewx\.drivers\.te923: [0-9a-f]{2,3} : [0-9a-f]{2,3}",
                   "weewx\.drivers\.te923: VER  BUF[1]=",
                   "weewx\.drivers\.te923: VER  bar=",
                   "weewx\.drivers\.te923: BAT  BUF[1]=",
                   "weewx\.drivers\.te923: BAT  rain=",
                   "weewx\.drivers\.te923: ALT  ",
                   "weewx\.drivers\.te923: LOC  ",
                   "weewx\.drivers\.te923: HIS  BUF[3]=",
                   "weewx\.drivers\.te923: record_index=",
                   "weewx\.drivers\.te923: count=",
                   "weewx\.drivers\.te923: gen_records: since_ts",
                   "weewx\.drivers\.te923: gen_records: yield",
                   "weewx\.drivers\.te923: gen_records: reading",
                   "weewx\.drivers\.te923: get_record at address",
                   "weewx\.drivers\.te923: REC  ",
                   "weewx\.drivers\.te923: get_record: found record",
                   "weewx\.drivers\.ultimeter: Driver version is",
                   "weewx\.drivers\.ultimeter: Using serial port",
                   "weewx\.drivers\.ultimeter: Open serial port",
                   "weewx\.drivers\.ultimeter: Close serial port",
                   "weewx\.drivers\.ultimeter: Station time: day:",
                   "weewx\.drivers\.ultimeter: Station said:",
                   "weewx\.drivers\.wmr9x8: Opened up serial port",
                   "weewx\.drivers\.wmr9x8: driver version is",
                   "weewx\.drivers\.wmr9x8: sensor map is",
                   "weewx\.drivers\.wmr9x8: Received WMR9x8 data packet",
                   "weewx\.drivers\.wmr9x8: Advancing buffer by one for the next potential packet",
                   "weewx\.drivers\.wmr9x8: wmr9x8: Running genLoopPackets",
                   "weewx\.drivers\.wmr100: Driver version is",
                   "weewx\.drivers\.wmr100: Sensor map is",
                   "weewx\.drivers\.wmr200: read_device\(\):",
                   "weewx\.drivers\.wmr200: No data received in",
                   "weewx\.drivers\.wmr200: write_device\(\):",
                   "weewx\.drivers\.wmr200: Processing ",
                   "weewx\.drivers\.wmr200:  Packet cooked:",
                   "weewx\.drivers\.wmr200: Time drift between host and console in seconds:",
                   "weewx\.drivers\.wmr200: Using pc time adjusting archive record time by",
                   "weewx\.drivers\.wmr200:   Archive packet num_temp_sensors:",
                   "weewx\.drivers\.wmr200:   Wind Dir:",
                   "weewx\.drivers\.wmr200:   Gust:",
                   "weewx\.drivers\.wmr200:   Windchill:",
                   "weewx\.drivers\.wmr200:   Rain packets:",
                   "weewx\.drivers\.wmr200:   Rain rate:",
                   "weewx\.drivers\.wmr200:   Total rain_total:",
                   "weewx\.drivers\.wmr200:   Last rain ",
                   "weewx\.drivers\.wmr200:   adjust_rain rain_total:",
                   "weewx\.drivers\.wmr200:   Initializing [^\t\n\r\f\v]+.rain_total_last to",
                   "weewx\.drivers\.wmr200:   UV index:",
                   "weewx\.drivers\.wmr200:   Forecast:",
                   "weewx\.drivers\.wmr200:   Raw pressure:",
                   "weewx\.drivers\.wmr200:   Altitude corrected pressure:",
                   "weewx\.drivers\.wmr200:   Temperature id:",
                   "weewx\.drivers\.wmr200:   Humidity id:",
                   "weewx\.drivers\.wmr200:   Dew point id:",
                   "weewx\.drivers\.wmr200:   Heat id:",
                   "weewx\.drivers\.wmr200: Skipped bytes before resync:",
                   "weewx\.drivers\.wmr200: Created watchdog thread to poke for live data every",
                   "weewx\.drivers\.wmr200: Started watchdog thread live data",
                   "weewx\.drivers\.wmr200: Watchdog received",
                   "weewx\.drivers\.wmr200: Watchdog thread exiting",
                   "weewx\.drivers\.wmr200: Created USB polling thread to read block on device",
                   "weewx\.drivers\.wmr200: USB polling device thread for live data launched",
                   "weewx\.drivers\.wmr200: USB polling device thread signaled to start",
                   "weewx\.drivers\.wmr200: USB polling device thread exiting",
                   "weewx\.drivers\.wmr200: Flushed USB device",
                   "weewx\.drivers\.wmr200: driver version is",
                   "weewx\.drivers\.wmr200: sensor map is",
                   "weewx\.drivers\.wmr200: Configuration setup",
                   "weewx\.drivers\.wmr200:   Log sensor faults:",
                   "weewx\.drivers\.wmr200:   Using PC Time:",
                   "weewx\.drivers\.wmr200:   Erase archive data:",
                   "weewx\.drivers\.wmr200:   Archive interval: ",
                   "weewx\.drivers\.wmr200:   Archive threshold:",
                   "weewx\.drivers\.wmr200: Poked device for live data",
                   "weewx\.drivers\.wmr200: Received packet count live:",
                   "weewx\.drivers\.wmr200: Received bytes:",
                   "weewx\.drivers\.wmr200: Packet archive queue len:",
                   "weewx\.drivers\.wmr200: Packet raw:",
                   "weewx\.drivers\.wmr200:   Queuing live packet rx:",
                   "weewx\.drivers\.wmr200:   Queuing archive packet rx:",
                   "weewx\.drivers\.wmr200:   Acknowledged control packet rx:",
                   "weewx\.drivers\.wmr200: genLoop\(\) phase getting live packets",
                   "weewx\.drivers\.wmr200: genLoop\(\) Yielding live queued packet id:",
                   "weewx\.drivers\.wmr200: genArchive\(\) phase getting archive packets since",
                   "weewx\.drivers\.wmr200: genArchive() Unable to process archive packets until live packet received",
                   "weewx\.drivers\.wmr200: genArchive\(\) Yielding received archive record after requested timestamp"
                   "weewx\.drivers\.wmr200: genStartup\(\) phase getting archive packets since",
                   "weewx\.drivers\.wmr200: genStartup\(\) Database initialization",
                   "weewx\.drivers\.wmr200: genStartup\(\) Delaying archive packet processing until live packet received",
                   "weewx\.drivers\.wmr200: genStartup\(\) Still receiving archive packets cnt",
                   "weewx\.drivers\.wmr200: genStartup\(\) Yielding received archive record cnt:",
                   "weewx\.drivers\.wmr200: genStartup\(\) phase exiting",
                   "weewx\.drivers\.wmr200: genStartup\(\) Yielded \d+ packets in",
                   "weewx\.drivers\.wmr200: genStartup\(\) Average packets per minute:",
                   "weewx\.drivers\.wmr200: USB polling thread expired",
                   "weewx\.drivers\.wmr200: Watchdog thread expired",
                   "weewx\.drivers\.wmr200: Driver gracefully exiting",
                   "weewx\.drivers\.wmr200: sensors: ",
                   "weewx\.drivers\.wmr200: fields: ",
                   "weewx\.drivers\.wmr300: driver version is",
                   "weewx\.drivers\.wmr300: usb info:",
                   "weewx\.drivers\.wmr300: sensor map is",
                   "weewx\.drivers\.wmr300: history limit is",
                   "weewx\.drivers\.wmr300: communication established:",
                   "weewx\.drivers\.wmr300: init_comm: send initial heartbeat",
                   "weewx\.drivers\.wmr300: init_comm: try to read",
                   "weewx\.drivers\.wmr300: init_comm: send initialization",
                   "weewx\.drivers\.wmr300: init_comm: try to read",
                   "weewx\.drivers\.wmr300: initialization completed in",
                   "weewx\.drivers\.wmr300: init history attempt \d+ of",
                   "weewx\.drivers\.wmr300: init history cmd=",
                   "weewx\.drivers\.wmr300: init history completed after attempt",
                   "weewx\.drivers\.wmr300: finish history attempt",
                   "weewx\.drivers\.wmr300: finish history completed after attempt",
                   "weewx\.drivers\.wmr300: dump history",
                   "weewx\.drivers\.wmr300: (Clearing|Reading) records since",
                   "weewx\.drivers\.wmr300: New historical record for",
                   "weewx\.drivers\.wmr300: History read completed:",
                   "weewx\.drivers\.wmr300: History read in progress:"
                   "weewx\.drivers\.wmr300: ignored packet type",
                   "weewx\.drivers\.wmr300: History read nearly complete:",
                   "weewx\.drivers\.wmr300: request station status:",
                   "weewx\.drivers\.wmr300: Yield delayed for",
                   "weewx\.drivers\.wmr300: history buffer at",
                   "weewx\.drivers\.wmr300: USB Read delayed for",
                   "weewx\.drivers\.wmr300: Loop data packets in heartbeat interval",
                   "weewx\.drivers\.wmr300: raw packet:",
                   "weewx\.drivers\.wmr300: rain=",
                   "weewx\.drivers\.wmr300: converted packet:",
                   "weewx\.drivers\.wmr300: read: ",
                   "weewx\.drivers\.wmr300: write: ",
                   "weewx\.drivers\.wmr300: flush buffer",
                   "weewx\.drivers\.wmr300: flush: discarded \d+ bytes",
                   "weewx\.drivers\.wmr300: [^\t\n\r\f\v]+ counts; ",
                   "weewx\.drivers\.wmr300: Found station at bus=",
                   "weewx\.drivers\.wmr300: decode: ",
                   "weewx\.drivers\.wmr300: history index: ",
                   "weewx\.drivers\.ws1: driver version is",
                   "weewx\.drivers\.ws1: using [a-z]{5} port",
                   "weewx\.drivers\.ws1: open serial port",
                   "weewx\.drivers\.ws1: close serial port",
                   "weewx\.drivers\.ws1: bytes: '",
                   "weewx\.drivers\.ws1: Connecting to",
                   "weewx\.drivers\.ws1: Will retry in",
                   "weewx\.drivers\.ws1: Closing connection to",
                   "weewx\.drivers\.ws1: Attempting to find record start",
                   "weewx\.drivers\.ws1: \(searching...\) buf:",
                   "weewx\.drivers\.ws1: Record start found!",
                   "weewx\.drivers\.ws1: \(found!\) buf:",
                   "weewx\.drivers\.ws1: buf is CRLF",
                   "weewx\.drivers\.ws1: buf has \d+ exclamation points.",
                   "weewx\.drivers\.ws1: buf: ",
                   "weewx\.drivers\.ws23xx: driver version is",
                   "weewx\.drivers\.ws23xx: serial port is",
                   "weewx\.drivers\.ws23xx: polling interval is",
                   "weewx\.drivers\.ws23xx: using \d+ second polling interval for",
                   "weewx\.drivers\.ws23xx: Waiting \d+ seconds before retry",
                   "weewx\.drivers\.ws23xx: create LinuxSerialPort",
                   "weewx\.drivers\.ws23xx: create Ws2300",
                   "weewx\.drivers\.ws23xx: station enter",
                   "weewx\.drivers\.ws23xx: station exit",
                   "weewx\.drivers\.ws23xx: close LinuxSerialPort",
                   "weewx\.drivers\.ws23xx: station clock is",
                   "weewx\.drivers\.ws23xx: station archive interval is \d+ minutes",
                   "weewx\.drivers\.ws23xx: record count is",
                   "weewx\.drivers\.ws23xx: gen_records: since_ts=",
                   "weewx\.drivers\.ws23xx: using (computer|station) clock with latest_ts",
                   "weewx\.drivers\.ws23xx: count is \d+ to satisfy timestamp",
                   "weewx\.drivers\.ws23xx: downloading \d+ records from station",
                   "weewx\.drivers\.ws28xx: frame length is",
                   "weewx\.drivers\.ws28xx: (([a-zA-Z0-9]{2}) )+",
                   "weewx\.drivers\.ws28xx: driver version is",
                   "weewx\.drivers\.ws28xx: frequency is",
                   "weewx\.drivers\.ws28xx: no new weather data",
                   "weewx\.drivers\.ws28xx: Scanning historical records",
                   "weewx\.drivers\.ws28xx: Scanned ",
                   "weewx\.drivers\.ws28xx: Found \d+ historical records",
                   "weewx\.drivers\.ws28xx: get station configuration",
                   "weewx\.drivers\.ws28xx: _WeatherState=",
                   "weewx\.drivers\.ws28xx: _TempIndoor=",
                   "weewx\.drivers\.ws28xx: _HumidityIndoor=",
                   "weewx\.drivers\.ws28xx: _TempOutdoor=",
                   "weewx\.drivers\.ws28xx: _HumidityOutdoor=",
                   "weewx\.drivers\.ws28xx: _Windchill=",
                   "weewx\.drivers\.ws28xx: _Dewpoint=",
                   "weewx\.drivers\.ws28xx: _WindSpeed=",
                   "weewx\.drivers\.ws28xx: _Gust=",
                   "weewx\.drivers\.ws28xx: _WindDirection=",
                   "weewx\.drivers\.ws28xx: _WindDirection1=",
                   "weewx\.drivers\.ws28xx: _WindDirection2=",
                   "weewx\.drivers\.ws28xx: _WindDirection3=",
                   "weewx\.drivers\.ws28xx: _WindDirection4=",
                   "weewx\.drivers\.ws28xx: _WindDirection=5",
                   "weewx\.drivers\.ws28xx: _RainLastMonth=",
                   "weewx\.drivers\.ws28xx: _RainLastWeek=",
                   "weewx\.drivers\.ws28xx: _Rain24H=",
                   "weewx\.drivers\.ws28xx: _Rain1H=",
                   "weewx\.drivers\.ws28xx: _RainTotal=",
                   "weewx\.drivers\.ws28xx: PressureRel_hPa=",
                   "weewx\.drivers\.ws28xx: PressureRel_inHg=",
                   "weewx\.drivers\.ws28xx: setResetMinMaxFlags:",
                   "weewx\.drivers\.ws28xx: testConfigChanged: checksum not changed:",
                   "weewx\.drivers\.ws28xx: testConfigChanged: checksum or resetMinMaxFlags changed:",
                   "weewx\.drivers\.ws28xx: OutBufCS=",
                   "weewx\.drivers\.ws28xx: InBufCS=",
                   "weewx\.drivers\.ws28xx: ClockMode=",
                   "weewx\.drivers\.ws28xx: TemperatureFormat=",
                   "weewx\.drivers\.ws28xx: PressureFormat=",
                   "weewx\.drivers\.ws28xx: RainFormat=",
                   "weewx\.drivers\.ws28xx: WindspeedFormat=",
                   "weewx\.drivers\.ws28xx: WeatherThreshold=",
                   "weewx\.drivers\.ws28xx: StormThreshold=",
                   "weewx\.drivers\.ws28xx: LCDContrast=",
                   "weewx\.drivers\.ws28xx: LowBatFlags=",
                   "weewx\.drivers\.ws28xx: WindDirAlarmFlags=",
                   "weewx\.drivers\.ws28xx: OtherAlarmFlags=",
                   "weewx\.drivers\.ws28xx: HistoryInterval=",
                   "weewx\.drivers\.ws28xx: TempIndoor_Min=",
                   "weewx\.drivers\.ws28xx: TempIndoor_Max=",
                   "weewx\.drivers\.ws28xx: TempOutdoor_Min=",
                   "weewx\.drivers\.ws28xx: TempOutdoor_Max=",
                   "weewx\.drivers\.ws28xx: HumidityIndoor_Min=",
                   "weewx\.drivers\.ws28xx: HumidityIndoor_Max=",
                   "weewx\.drivers\.ws28xx: HumidityOutdoor_Min=",
                   "weewx\.drivers\.ws28xx: HumidityOutdoor_Max=",
                   "weewx\.drivers\.ws28xx: Rain24HMax=",
                   "weewx\.drivers\.ws28xx: GustMax=",
                   "weewx\.drivers\.ws28xx: PressureRel_hPa_Min=",
                   "weewx\.drivers\.ws28xx: PressureRel_inHg_Min=",
                   "weewx\.drivers\.ws28xx: PressureRel_hPa_Max=",
                   "weewx\.drivers\.ws28xx: PressureRel_inHg_Max=",
                   "weewx\.drivers\.ws28xx: ResetMinMaxFlags=",
                   "weewx\.drivers\.ws28xx: Time",
                   "weewx\.drivers\.ws28xx: TempIndoor=",
                   "weewx\.drivers\.ws28xx: HumidityIndoor=",
                   "weewx\.drivers\.ws28xx: TempOutdoor=",
                   "weewx\.drivers\.ws28xx: HumidityOutdoor=",
                   "weewx\.drivers\.ws28xx: PressureRelative=",
                   "weewx\.drivers\.ws28xx: RainCounterRaw=",
                   "weewx\.drivers\.ws28xx: WindSpeed=",
                   "weewx\.drivers\.ws28xx: WindDirection=",
                   "weewx\.drivers\.ws28xx: Gust=",
                   "weewx\.drivers\.ws28xx: GustDirection=",
                   "weewx\.drivers\.ws28xx: setFrequency:",
                   "weewx\.drivers\.ws28xx: setDeviceID:",
                   "weewx\.drivers\.ws28xx: console is paired to device with ID",
                   "weewx\.drivers\.ws28xx: setLastStatCache: seen=",
                   "weewx\.drivers\.ws28xx: setCommModeInterval to",
                   "weewx\.drivers\.ws28xx: setTransceiverSerialNumber to",
                   "weewx\.drivers\.ws28xx: found transceiver at bus=",
                   "weewx\.drivers\.ws28xx: skipping transceiver with serial",
                   "weewx\.drivers\.ws28xx: manufacturer:",
                   "weewx\.drivers\.ws28xx: product:",
                   "weewx\.drivers\.ws28xx: interface:",
                   "weewx\.drivers\.ws28xx: claiming USB interface",
                   "weewx\.drivers\.ws28xx: releasing USB interface",
                   "weewx\.drivers\.ws28xx: CCommunicationService.init",
                   "weewx\.drivers\.ws28xx: buildFirstConfigFrame: cs=",
                   "weewx\.drivers\.ws28xx: buildConfigFrame",
                   "weewx\.drivers\.ws28xx: buildTimeFrame: cs=",
                   "weewx\.drivers\.ws28xx: buildACKFrame: action=",
                   "weewx\.drivers\.ws28xx: buildACKFrame: morphing action from",
                   "weewx\.drivers\.ws28xx: buildACKFrame: idx:",
                   "weewx\.drivers\.ws28xx: handleWsAck",
                   "weewx\.drivers\.ws28xx: handleConfig:",
                   "weewx\.drivers\.ws28xx: handleCurrentData:",
                   "weewx\.drivers\.ws28xx: handleHistoryData:",
                   "weewx\.drivers\.ws28xx: handleHistoryData: time=",
                   "weewx\.drivers\.ws28xx: handleHistoryData: request",
                   "weewx\.drivers\.ws28xx: handleHistoryData: start_index=",
                   "weewx\.drivers\.ws28xx: handleHistoryData: remove previous record",
                   "weewx\.drivers\.ws28xx: handleHistoryData: appending history record",
                   "weewx\.drivers\.ws28xx: handleHistoryData: skip record:",
                   "weewx\.drivers\.ws28xx: handleHistoryData: next=",
                   "weewx\.drivers\.ws28xx: handleNextAction: a1 \(first-time config\)",
                   "weewx\.drivers\.ws28xx: handleNextAction: a2 \(set config data\)",
                   "weewx\.drivers\.ws28xx: handleNextAction: a3 \(set time data\)",
                   "weewx\.drivers\.ws28xx: Time:",
                   "weewx\.drivers\.ws28xx: Skip settime; time difference",
                   "weewx\.drivers\.ws28xx: handleNextAction:",
                   "weewx\.drivers\.ws28xx: generateResponse:",
                   "weewx\.drivers\.ws28xx: initTransceiver: frequency_standard",
                   "weewx\.drivers\.ws28xx: base frequency:",
                   "weewx\.drivers\.ws28xx: frequency correction:",
                   "weewx\.drivers\.ws28xx: frequency registers:",
                   "weewx\.drivers\.ws28xx: transceiver identifier:",
                   "weewx\.drivers\.ws28xx: transceiver serial:",
                   "weewx\.drivers\.ws28xx: startRFThread: spawning RF thread",
                   "weewx\.drivers\.ws28xx: stopRFThread: waiting for RF thread to terminate",
                   "weewx\.drivers\.ws28xx: setting up rf communication",
                   "weewx\.drivers\.ws28xx: starting rf communication",
                   "weewx\.drivers\.ws28xx: stopping rf communication",
                   "weewx\.drivers\.ws28xx: SetTime/SetConfig data written"
                   ],
        'sum': {
            'cheetah_generated': "weewx\.cheetahgenerator: Generated (\d+) files for report",
            'images_generated': "weewx\.imagegenerator: Generated (\d+) images for",
            'engine_garbage': "weewx\.engine: Garbage collected (\d+) objects",
            'copy_copied': "weewx\.reportengine: Copied (\d+) files to",
            'rsync_uploads': "rsync\'d (\d+) files"
        },
        'itemised': {
            'weewxd': {
                'weewxd_startups': "__main__: Starting up weewx version",
                'weewxd_hup_restarts': "__main__: Received signal HUP\. Restarting",
                'weewxd_sig_term': "__main__: Received signal TERM \(15\)",
                'weewxd_keyboard_interrupt': "__main__: Keyboard interrupt",
                'weewxd_unex_main_loop_exit': "__main__: Unexpected exit from main loop. Program exiting",
                'weewxd_unrecoverable': "__main__: Caught unrecoverable exception:",
                'weewxd_recovery_attempts': "__main__: retrying[.]+",
                'errors': {
                    'weewxd_unable_load_driver': "__main__: Unable to load driver",
                    'weewxd_io_error': "__main__: Caught WeeWxIOError:",
                    'weewxd_dbase_conn_exception': "__main__: Database connection exception:",
                    'weewxd_dbase_operational_error_exception': "__main__: Database OperationalError exception:",
                    'weewxd_os_error': "__main__: Caught OSError:",
                }
            },
            'engine' : {
                'engine_unable_launch_rep_thread': "weewx\.engine: Unable to launch report thread",
                'engine_unable_shut_rep_thread': "weewx\.engine: Unable to shut down StdReport thread",
                'errors': {
                    'engine_driver_import_fail': "weewx\.engine: Import of driver failed:",
                    'engine_packet_loop_exit': "weewx\.engine: Internal error\. Packet loop has exited",
                    'engine_stdcal_loop_error': "weewx\.engine: StdCalibration loop error",
                    'engine_stdcal_archive_error': "weewx\.engine: StdCalibration archive error",
                    'engine_archive_int_error': "weewx\.engine: The archive interval in the configuration file",
                    'engine_unknown_rec_gen': "weewx\.engine: Unknown type of record generation:",
                    'engine_archive_delay_long': "weewx\.engine: Archive delay \(\d+\) is unusually long",
                    'engine_ignore_hist_rec': "weewx\.engine: ignore historical record:",
                    'engine_catchup_error': "Internal error detected\. Catchup abandoned",
                    'engine_catchup_error_msg': "weewx\.engine: \*\*\*\* ",
                    'engine_read_time_error': "weewx\.engine: Error reading time",
                    'engine_rep_thread_running': "weewx\.engine: Launch of report thread aborted: existing report thread still running",
                    'engine_prev_rep_thread_running': "weewx\.engine: Previous report thread has been running"
                }
            },
            'copy': {
#                'copy_copied': "weewx\.reportengine: Copied (\d+) files to",
            },
            'ftp': {
                'ftp': "weewx\.reportengine: ftpgenerator: Ftp'd (\d+) files in (\d+) seconds",
                'ftp_ftps_not_supported': "weeutil\.ftpupload: Your version of Python does not support FTPS. Using insecure connection.",
                'ftp_uploads': "weeutil\.ftpupload: ftpupload: Uploaded file",
                'ftp_fails': "weeutil\.ftpupload: ftpupload: Failed to upload file",
                'errors': {
                    'ftp_exception': "weewx\.reportengine: ftpgenerator: Caught exception",
                    'ftp_connect_fail_attempt': "weeutil\.ftpupload: Unable to connect or log into server",
                    'ftp_connect_fail': "weeutil\.ftpupload: Attempted \d+ times to connect to server",
                    'ftp_upload_fail_attempt': "weeutil\.ftpupload: Attempt \#\d+. Failed uploading",
                    'ftp_make_dir_error': "weeutil\.ftpupload: Got error while attempting to make remote directory",
                    'ftp_error': "weeutil\.ftpupload:     \*\*\*\*  Error:",
                    'ftp_make_dir_fail': "weeutil\.ftpupload: Unable to create remote directory"
                }
            },
            'manager': {
                'manager_cannot_open_db_no_schema': "weewx\.manager: Cannot open database, and no schema specified",
                'manager_rec_null_time': "weewx\.manager: Archive record with null time encountered",
                'manager_archive_records_added': "weewx\.manager: Added record [a-zA-Z0-9() :-]+ to database",
                'manager_summary_records_added': "weewx\.manager: Added record [a-zA-Z0-9() :-]+ to daily summary",
                'manager_drop_summaries':"weewx\.manager: Dropping daily summary tables from",
                'errors': {
                    'manager_cannot_get_columns': "weewx\.manager: Cannot get columns of table",
                    'manager_unable_create_table': "weewx\.manager: Unable to create table '",
                    'manager_unable_add_rec': "weewx\.manager: Unable to add record",
                    'manager_replace_failed': "weewx\.manager: Replace failed for database",
                    'manager_drop_summaries_fail': "weewx\.manager: Dropped daily summary tables from database",
                }
            },
            'qc': {
                'qc_no_config': "weewx\.qc: No QC information in config file",
#                'qc_outside_limits': "weewx\.qc: %s %s value '%s' %s outside limits"
            },
            'reportengine': {
                'reportengine_ignored': "weewx\.reportengine: [ *]+  Report ignored",
                'reportengine_report_timing_skipped': "weewx\.reportengine: Report '[a-zA-Z0-9-_]+' skipped due to report_timing setting",
                'report_engine_generator_ignored': "weewx\.reportengine: [ *]+ Generator ignored",
                'report_engine_generator_terminated': "weewx\.reportengine: [ *]+ Generator terminated",
                'errors': {
                    'reportengine_invalid_report_timing': "weewx\.reportengine: Invalid report_timing setting for report",
                    'reportengine_invalid_report_timing_error': "weewx\.reportengine:       \*\*\*\*  ",
                    'reportengine_cannot_instantiate_gen': "weewx\.reportengine: Unable to instantiate generator",
                    'reportengine_cannot_instantiate_gen_error': "weewx\.reportengine:         \*\*\*\*  ",
                    'reportengine_unrecov_exception_gen': "weewx\.reportengine: Caught unrecoverable exception in generator",
                    'reportengine_unrecov_exception_gen_error': "weewx\.reportengine:         \*\*\*\*  ",
                    'reportengine_cannot_read_skin_conf': "weewx\.reportengine: Cannot read skin configuration file",
                    'reportengine_failed_read_skin_conf': "weewx\.reportengine: Failed to read skin configuration file",
                }
            },
            'rsync': {
                'rsync_executed': "weeutil\.rsyncupload: rsync executed in",
                'rsync_files_uploaded': "weeutil\.rsyncupload: rsync'd (\d+) files \(([0-9,.]+).+\) in",
                'errors': {
                    'rsync_exception': "weewx\.reportengine: rsyncgenerator: Caught exception",
                    'rsync_not_installed': "rsync does not appear to be installed on",
                    'rsync_errors': "weeutil\.rsyncupload: .+ reported errors:"
                }
            },
            'restx': {
                'restx_no_augment': "weewx\.restx: No database specified\. Augmentation from database skipped",
                'restx_skipped': "weewx\.restx: ([^:]*): Skipped record",
                'restx_bad_login_wait': "weewx\.restx: ([^:]*): Bad login; waiting",
                'restx_bad_login_terminate': "weewx\.restx: ([^:]*): Bad login; no retry specified. Terminating",
                'restx_bad_cert_terminate': "weewx\.restx: .+: Bad SSL certificate; no retry specified. Terminating",
                'restx_published': "weewx\.restx: ([^:]*): Published record",
                'restx_no_stn_url': "weewx\.restx: StationRegistry: Station will not be registered: no station_url specified",
                'restc_no_awekas_augment': "weewx\.restx: AWEKAS: No database specified. Augmentation from database skipped.",
                'errors': {
                    'restx_shut_thread_fail': "weewx\.restx: Unable to shut down .+ thread",
                    'restx_db_error': "weewx\.restx: ([^:]*): Database OperationalError",
                    'restx_upload_errors': "weewx\.restx: ([^:]*): Failed to publish",
                    'restx_bad_cert_wait': "weewx\.restx: ([^:]*): Bad SSL certificate \(",
                    'restx_unexpect_exception': "weewx\.restx: ([^:]*): Unexpected exception of type",
                    'restx_thread_terminate': "weewx\.restx: ([^:]*): Thread terminating. Reason:",
                    'restx_upload_attempt_fail_code': "weewx\.restx: ([^:]*): Failed upload attempt \d+: Code",
                    'restx_upload_attempt_fail_exception': "weewx\.restx: ([^:]*): Failed upload attempt \d+: ",
                    'restx_bad_server': "weewx\.restx: ([^:]*): Bad server address:",
                    'restx_connection_error_attempt': "weewx\.restx: ([^:]*): Attempt \d+ to .+:\d+. Connection error:",
                    'restx_socket_error_attempt': "weewx\.restx: ([^:]*): Attempt \d+ to .+:\d+. Socket send error:",
                    'restx_response_exception': "weewx\.restx: ([^:]*): Exception .+ when looking for response to",
                    'restx_missing_config': "weewx\.restx: ([^:]*): No config info. Skipped.",
                    'restx_missing_option': "weewx\.restx: ([^:]*): Data will not be posted: Missing option"
                },
            },
            'units': {
                'errors': {
                    'units_cannot_convert': "weewx\.units: Unable to convert from"
                }
            },
            'wxformulas': {
                'errors': {
                    'wxformulas_rain_counter_reset': "weewx\.wxformulas: Rain counter reset detected"
                }
            },
            'wxservices': {
                'wxservices_et_mixed_units': "weewx\.wxservices: Mixed unit system not allowed in ET calculation",
                'errors': {
                    'wxservices_unknown_extens_type': "weewx\.wxservices: Unknown extensible type",
                    'wxservices_unknown_agg': "weewx\.wxservices: Unknown aggregation",
                    'wxservices_et_failed': "weewx\.wxservices: Calculation of evapotranspiration failed",
                    'wxservices_db_error_rainrate': "weewx\.wxservices: Database error while initializing rainRate:",
                }
            },
            'image_generator': {
                'errors': {
                    'image_gen_agg_errors': "weewx\.imagegenerator: aggregate interval required for aggregate type|weewx\.imagegenerator: line type \S+ skipped",
                    'image_gen_gap_frac': "weewx\.imagegenerator: Gap fraction (0-1.) outside range",
                    'image_gen_unable_save_file': "weewx\.imagegenerator: Unable to save to file",
                }
            },
            'maxwindspeed_fix': {
                'maxwindspeed_fix_applied': "weewx\.database: maxwindspeed: Maximum windSpeed calculated",
                'errors': {
                    'maxwindspeed_fix_fail': "weewx\.database: maxwindspeed: .+ not applied:"
                }
            },
            'interval_weighting_fix': {
                'db_interval_weight_applied': "weewx\.database: intervalweighting: Processed .+ consisting of .+ were updated",
                'errors': {
                    'db_interval_weight_not_applied': "weewx\.database: intervalweighting: .+ not applied",
                    'db_interval_weight_fix_fail': "weewx\.database: intervalweighting: Interval weighting of .+ failed:"
                }
            },
            'acurite': {
                'acurite_loop_max_tries_error': "weewx\.drivers\.acurite: Max retries \(\d+\) exceeded for LOOP data",
                'acurite_rain_count_dec': "weewx\.drivers\.acurite: rain counter decrement ignored:",
                'errors': {
                    'acurite_fail_loop_attempt': "weewx\.drivers\.acurite: Failed attempt \d+ of %d+ to get LOOP data:",
                    'acurite_r3_read_fail': "weewx\.drivers\.acurite: R3: read failed \d+",
                    'acurite_r3_usb_mode_3': "weewx\.drivers\.acurite: R3: put station in USB mode 3 to enable R3 data",
                    'acurite_cannot_find_device': "weewx\.drivers\.acurite: Cannot find USB device with VendorID=",
                    'acurite_cannot_claim_usb': "weewx\.drivers\.acurite: Unable to claim USB interface",
                    'acurite_iface_release_fail': "weewx\.drivers\.acurite: release interface failed",
                    'acurite_r1_stale_data': "weewx\.drivers\.acurite: R1: ignoring stale data (rssi indicates no communication from sensors):",
                    'acurite_r1_bad_length': "weewx\.drivers\.acurite: R1: bad length:",
                    'acurite_r1_bad_format': "weewx\.drivers\.acurite: R1: bad format:",
                    'acurite_r1_no_sensors': "weewx\.drivers\.acurite: R1: no sensors found:",
                    'acurite_r1_bogus_flavor': "weewx\.drivers\.acurite: R1: bogus message flavor",
                    'acurite_r1_bogus_final_byte': "weewx\.drivers\.acurite: R1: bogus final byte",
                    'acurite_r2_bad_length': "weewx\.drivers\.acurite: R2: bad length:",
                    'acurite_r2_bad_format': "weewx\.drivers\.acurite: R2: bad format:",
                    'acurite_r3_bad_value': "weewx\.drivers\.acurite: R3: bad value in row",
                    'acurite_r3_bad_length': "weewx\.drivers\.acurite: R3: bad length in row",
                    'acurite_r3_bad_format': "weewx\.drivers\.acurite: R3: bad format in row",
                    'acurite_r2_unknown_cal': "weewx\.drivers\.acurite: R2: unknown calibration constants:",
                    'acurite_r2_const_changed': "weewx\.drivers\.acurite: R2: constants changed: old:"
                }
            },
            'cc3000': {
                'cc3000_mem_usage_fail': "weewx\.drivers\.cc3000: Memory check: Cannot determine memory usage",
                'cc3000_cleared_memory': "weewx\.drivers\.cc3000: Clearing all records from logger",
                'cc3000_max_retries': "weewx\.drivers\.cc3000: Max retries (%d) exceeded",
                'cc3000_no_sensor_data': "weewx\.drivers\.cc3000: No data from sensors",
                'cc3000_set_time': "weewx\.drivers\.cc3000: Set time to",
                'cc3000_set_dst': "weewx\.drivers\.cc3000: Set DST to",
                'cc3000_set_units': "weewx\.drivers\.cc3000: Set units to",
                'cc3000_set_log_interval': "weewx\.drivers\.cc3000: Set logging interval to",
                'cc3000_set_channel': "weewx\.drivers\.cc3000: Set channel to",
                'cc3000_set_baro_offset': "weewx\.drivers\.cc3000: Set barometer offset to",
                'cc3000_reset_max': "weewx\.drivers\.cc3000: Reset max values",
                'cc3000_reset_min': "weewx\.drivers\.cc3000: Reset min values",
                'cc3000_mem_clear': "weewx\.drivers\.cc3000: MEM=CLEAR succeeded.",
                'cc3000_reset_rain': "weewx\.drivers\.cc3000: Reset rain counter",
                'errors': {
                    'cc3000_get_data_fail_attempt': "weewx\.drivers\.cc3000: Failed attempt \d+ of \d+ to get data:",
                    'cc3000_gettime_fail': "weewx\.drivers\.cc3000: getTime failed:",
                    'cc3000_init_fail_attempt': "weewx\.drivers\.cc3000: Failed attempt \d+ of \d+ to initialize station:",
                    'cc3000_val_hdr_mismatch': "weewx\.drivers\.cc3000: Values/header mismatch:",
                    'cc3000_parse_fail': "weewx\.drivers\.cc3000: Parse failed for",
                    'cc3000_cmd_timeout_info': "weewx\.drivers\.cc3000: \S+: times: [^\t\n\r\f\v] -retrying",
                    'cc3000_echo_timeout': "weewx\.drivers\.cc3000: \S+: Reading cmd echo timed out",
                    'cc3000_retry_fail': "weewx\.drivers\.cc3000: \S+: Retry failed.",
                    'cc3000_unexpected_rec': "weewx\.drivers\.cc3000: Unexpected record"
                }
            },
            'fousb': {
                'fousb_read_block_change': "weewx\.drivers\.fousb: read_block change",
                'fousb_rain_count_dec': "weewx\.drivers\.fousb: ignoring spurious rain counter decrement",
                'fousb_rain_count_wrap': "weewx\.drivers\.fousb: rain counter wraparound detected",
                'fousb_power_cycles_attempted': "weewx\.drivers\.fousb: Attempting to power cycle",
                'fousb_power_cycles_completed': "weewx\.drivers\.fousb: Power cycle complete",
                'fousb_sync_to_station': "weewx\.drivers\.fousb: synchronised to",
                'fousb_unex_sensor_clk_change': "weewx\.drivers\.fousb: unexpected sensor clock change",
                'fousb_setting_sensor_clk': "weewx\.drivers\.fousb: setting sensor clock",
                'fousb_lost_sync': "weewx\.drivers\.fousb: lost sync",
                'fousb_missed_interval': "weewx\.drivers\.fousb: missed interval",
                'fousb_unexpected_clock_change': "weewx\.drivers\.fousb: unexpected station clock change",
                'fousb_setting_stn_clk': "weewx\.drivers\.fousb: setting station clock ",
                'fousb_lost_log_sync': "weewx\.drivers\.fousb: lost log sync",
                'errors': {
                    'fousb_get_interval_fail': "weewx\.drivers\.fousb: Get archive interval failed attempt %d+",
                    'fousb_cannot_find_device': "weewx\.drivers\.fousb: Cannot find USB device with Vendor=",
                    'fousb_cannot_claim_usb': "weewx\.drivers\.fousb: Unable to claim USB interface",
                    'fousb_station_status': "weewx\.drivers\.fousb: station status ",
                    'fousb_get_obs_fail': "weewx\.drivers\.fousb: get_observations failed:",
                    'fousb_invalid_data': "weewx\.drivers\.fousb: invalid data in get_records at",
                    'fousb_get_rec_fail': "weewx\.drivers\.fousb: get_records failed:",
                    'fousb_invalid_data_while_sync': "weewx\.drivers\.fousb: invalid data while synchronising at",
                    'fousb_unex_ptr_change': "weewx\.drivers\.fousb: unexpected ptr change",
                    'fousb_changing_format': "weewx\.drivers\.fousb: changing data format from",
                    'fousb_unstable_read': "weewx\.drivers\.fousb: unstable read: blocks differ for ptr",
                    'fousb_unrecog_magic_number': "weewx\.drivers\.fousb: unrecognised magic number",
                    'fousb_magic_num_changed': "weewx\.drivers\.fousb: magic number changed"
                }
            },
            'te923': {
                'errors': {
                    'te923_skip_dupe_ts': "weewx\.drivers\.te923: skip packet with duplidate timestamp",
                    'te923_cannot_find_device': "weewx\.drivers\.te923: Cannot find USB device with VendorID=",
                    'te923_cannot_claim_usb': "weewx\.drivers\.te923: Unable to claim USB interface",
                    'te923_rel_iface_fail': "weewx\.drivers\.te923: release interface failed:",
                    'te923_read_timeout': "weewx\.drivers\.te923: timeout while reading: ignoring bytes:",
                    'te923_wrong_num_bytes': "weewx\.drivers\.te923: read: wrong number of bytes:",
                    'te923_write_wrong_bytes': "weewx\.drivers\.te923: write: ack got wrong number of bytes:",
                    'te923_read_data_fail': "weewx\.drivers\.te923: Failed attempt \d+ of \d+ to read data:",
                    'te923_write_data_fail': "weewx\.drivers\.te923: Failed attempt \d+ of \d+ to write data:",
                    'te923_unrecog_mem_size': "weewx\.drivers\.te923: Unrecognised memory size",
                    'te923_rec_index_exceeds_mem': "weewx\.drivers\.te923: record index of \d+ exceeds memory size of",
                    'te923_too_many_rec': "weewx\.drivers\.te923: too many records requested \(\d+\), using",
                    'te923_gen_rec_skip': "weewx\.drivers\.te923: gen_records: skip",
                    'te923_no_data_at_add': "weewx\.drivers\.te923: get_record: no data at address",
                    'te923_unrecog_interval': "weewx\.drivers\.te923: Unrecognized archive interval"
                }
            },
            'ultimeter': {
                'ultimeter_set_time': "weewx\.drivers\.ultimeter: Set station time to",
                'ultimeter_set_year': "weewx\.drivers\.ultimeter: Set station year to",
                'ultimeter_set_logger_mode': "weewx\.drivers\.ultimeter: Set station to logger mode",
                'ultimeter_set_modem_mode': "weewx\.drivers\.ultimeter: Set station to modem mode",
                'ultimeter_readings_max_retries': "weewx\.drivers\.ultimeter: Max retries \(\d+\) exceeded for readings",
                'errors': {
                    'ultimeter_get_time_fail': "weewx\.drivers\.ultimeter: get_time failed:",
                    'ultimeter_get_readings_fail': "weewx\.drivers\.ultimeter: Failed attempt \d+ of \d+ to get readings:",
                    'ultimeter_decode_fail': "weewx\.drivers\.ultimeter: Decode failed for"
                }
            },
            'vantage': {
                 'vantage_wakeup_fail': "ERROR weewx\.drivers\.vantage: Unable to wake up console",
                 'vantage_no_ack': "weewx\.drivers\.vantage: No <ACK> received from console",
                 'vantage_send_crc_fail': "weewx\.drivers\.vantage: Unable to pass CRC16 check while sending data",
                 'vantage_send_cmd_max_retries': "weewx\.drivers\.vantage: Max retries exceeded while sending command",
                 'vantage_get_crc_fail': "weewx\.drivers\.vantage: Unable to pass CRC16 check while getting data",
                 'vantage_crc_timeout': "weewx\.drivers\.vantage: Timeout in get_data_with_crc16",
                 'vantage_loop_max_tries_error': "weewx\.drivers\.vantage: LOOP max tries \(\d+\) exceeded",
                 'vantage_dmpaft_max_ties': "weewx\.drivers\.vantage: DMPAFT max tries \(\d+\) exceeded",
                 'vantage_get_time_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while getting time",
                 'vantage_clock_set': "weewx\.drivers.vantage: Clock set to",
                 'vantage_set_time_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while setting time",
                 'vantage_cup_set': "weewx\.drivers\.vantage: Wind cup type set to",
                 'vantage_bucket_set': "weewx\.drivers\.vantage: Rain bucket type set to",
                 'vantage_rain_year_set': "weewx\.drivers\.vantage: Rain year start set to",
                 'vantage_barometer_cal_set': "weewx\.drivers\.vantage: Set barometer calibration",
                 'vantage_lat_set': "weewx\.drivers\.vantage: Station latitude set to",
                 'vantage_long_set': "weewx\.drivers\.vantage: Station longitude set to",
                 'vantage_interval_set': "weewx\.drivers\.vantage: Archive interval set to",
                 'vantage_lamp_set': "weewx\.drivers\.vantage: Lamp set to",
                 'vantage_trans_type_set': "weewx\.drivers\.vantage: Transmitter type for channel",
                 'vantage_retrans_set': "weewx\.drivers\.vantage: Retransmit set to",
                 'vantage_console_temp_log_set': "weewx\.drivers\.vantage: Console temperature logging set to",
                 'vantage_wind_cal_set': "weewx\.drivers\.vantage: Wind calibration set to",
                 'vantage_temp_cal_set': "weewx\.drivers\.vantage: Temperature calibration",
                 'vantage_hum_cal_set': "weewx\.drivers\.vantage: Humidity calibration",
                 'vantage_archive_mem_clear': "weewx\.drivers\.vantage: Archive memory cleared",
                 'vantage_clear_log_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while clearing log",
                 'vantage_inconsist_eeprom': "weewx\.drivers\.vantage: Inconsistent EEPROM calibration values",
                 'vantage_hardware_type_no_read': "weewx\.drivers\.vantage: Unable to read hardware type",
                 'vantage_eeprom_max_tries': "weewx\.drivers\.vantage: Max retries exceeded while getting EEPROM data at address",
                 'errors': {
                     'vantage_wakeup_retry_fail': "weewx\.drivers\.vantage: Retry #\d+ failed",
                     'vantage_send_crc_try': "weewx\.drivers\.vantage: send_data_with_crc16; try #\d+",
                     'vantage_send_cmd_try': "weewx\.drivers\.vantage: send_command; try #\d+ failed",
                     'vantage_get_crc_try': "weewx\.drivers\.vantage: Get_data_with_crc16; try #\d+ failed",
                     'vantage_serial_exception_read': "weewx\.drivers\.vantage: SerialException on read",
                     'vantage_serial_exception_write': "weewx\.drivers\.vantage: SerialException on write",
                     'vantage_socket_error': "weewx\.drivers\.vantage: Socket error while opening port",
                     'vantage_eth_no_conn': "weewx\.drivers\.vantage: Unable to connect to ethernet host",
                     'vantage_ip_read_error': "weewx\.drivers\.vantage: ip-read error",
                     'vantage_ip_write_error': "weewx\.drivers\.vantage: ip-write error",
                     'vantage_loop_try_error': "weewx\.drivers\.vantage: LOOP try #\d+; error",
                     'vantage_dmpaft_try_error': "weewx\.drivers\.vantage: DMPAFT try #\d+; error",
                     'vantage_determine_hardware_retry': "weewx\.drivers\.vantage: _determine_hardware; retry",
                     'vantage_unknown_bucket': "weewx\.drivers\.vantage: Unknown bucket type",
                     'vantage_unknown_loop': "weewx\.drivers\.vantage: Unknown LOOP packet type"
                }
            },
            'wmr9x8': {
                'wmr9x8_rx_wm918_data_packet': "weewx\.drivers\.wmr9x8: Received WM-918 data packet",
                'errors': {
                    'wmr9x8_invalid_packet': "weewx\.drivers\.wmr9x8: Invalid data packet"
                }
            },
            'wmr100': {
                'wmr100_usb_report_max_retries': "weewx\.drivers\.wmr100: Max retries exceeded while fetching USB reports",
                'errors': {
                    'wmr100_cannot_claim_usb': "weewx\.drivers\.wmr100: Unable to claim USB interface:",
                    'wmr100_cannot_find_device': "weewx\.drivers\.wmr100: Unable to find USB device",
                    'wmr100_malformed_packet': "weewx\.drivers\.wmr100: Malformed packet:",
                    'wmr100_checksum_exception': "weewx\.drivers\.wmr100: Exception while calculating checksum:",
                    'wmr100_buffer_length_bad checksum': "weewx\.drivers\.wmr100: Bad checksum on buffer of length",
                    'wmr100_unable_send_usb_ctl': "weewx\.drivers\.wmr100: Unable to send USB control message:",
                    'wmr100_bad_usb_report': "weewx\.drivers\.wmr100: Bad USB report received:"
                }
            },
            'wmr200': {
                'wmr200_device_not_spec': "weewx\.drivers\.wmr200: open_device() Device not specified.",
                'wmr200_no_usb_handle_read': "weewx\.drivers\.wmr200: read_device() No USB handle for usb_device Read",
                'wmr200_usb_overflow': "weewx\.drivers\.wmr200: USB read_device overflow error",
                'wmr200_no_usb_handle_write': "weewx\.drivers\.wmr200: No USB handle for usb_device Write",
                'wmr200_size_fail': "weewx\.drivers\.wmr200: Failed to extract size from packet",
                'wmr200_packet_to_small_comp_crc': "weewx\.drivers\.wmr200: Packet too small to compute 16 bit checksum",
                'wmr200_packet_too_small_cont_crc': "weewx\.drivers\.wmr200: Packet too small to contain 16 bit checksum",
                'wmr200_timestamp_not_set': "weewx\.drivers\.wmr200: timestamp_record() Timestamp not set in record",
                'wmr200_cooked_before_setup': "weewx\.drivers\.wmr200: print_cooked() called before proper setup",
                'wmr200_invalid_time_drift': "weewx\.drivers\.wmr200: timestamp_adjust_drift() called with invalid time drift",
                'wmr200_device_unresponsive': "weewx\.drivers\.wmr200: Device unresponsive after multiple resets",
                'wmr200_usb_read_error': "weewx\.drivers\.wmr200: USB device read error",
                'wmr200_reset_console': "weewx\.drivers\.wmr200: Reset console device",
                'wmr200_cannot_find_device': "weewx\.drivers\.wmr200: Unable to find device with VendorID=",
                'wmr200_usb_poll_thread_term': "weewx\.drivers\.wmr200: USB polling thread unexpectedly terminated",
                'wmr200_usb_poll_thread_alive': "weewx\.drivers\.wmr200: USB polling thread still alive",
                'wmr200_wdog_thread_alive': "weewx\.drivers\.wmr200: Watchdog thread still alive",
                'wmr200_ignore_rec': "weewx\.drivers\.wmr200: genArchive() Ignoring received archive record before requested timestamp",
                'wmr200_interval_zero': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record since interval is zero",
                'errors': {
                    'wmr200_cannot_get_timestamp': "weewx\.drivers\.wmr200: Packet length too short to get timestamp len",
                    'wmr200_index_decode_fail': "weewx\.drivers\.wmr200: [^\t\n\r\f\v]+ decode index failure",
                    'wmr200_cannot_open_usb': "weewx\.drivers\.wmr200: open_device() Unable to open USB interface. Reason:",
                    'wmr200_cannot_claim_usb': "weewx\.drivers\.wmr200: open_device() Unable to claim USB interface.",
                    'wmr200_cannot_release_iface': "weewx\.drivers\.wmr200: close_device() Unable to release device interface",
                    'wmr200_index_range_fail': "weewx\.drivers\.wmr200: read_device() Failed the index rage",
                    'wmr200_usb_read_error': "weewx\.drivers\.wmr200: read_device() USB Error",
                    'wmr200_write_cannot_send_usb_control': "weewx\.drivers\.wmr200: write_device() Unable to send USB control message",
                    'wmr200_unexpected_packet_size': "weewx\.drivers\.wmr200: Unexpected packet size act:",
                    'wmr200_no_get_key': "weewx\.drivers\.wmr200: Record get key not found in record key:",
                    'wmr200_no_set_key': "weewx\.drivers\.wmr200: Record set key not found in record key:",
                    'wmr200_record_update_fail': "weewx\.drivers\.wmr200: Record update failed to apply record:",
                    'wmr200_sensor_packet': "weewx\.drivers\.wmr200:  Sensor packet:",
                    'wmr200_checksum_miscompare': "weewx\.drivers\.wmr200: Checksum miscompare act:",
                    'wmr200_pressure_unknown': "weewx\.drivers\.wmr200:   Pressure unknown nibble:",
                    'wmr200_reset_cannot_send_usb_control': "weewx\.drivers\.wmr200: reset_console() Unable to send USB control",
                    'wmr200_unverified_interval': "weewx\.drivers\.wmr200: Unverified archive interval:",
                    'wmr200_restart_count': "weewx\.drivers\.wmr200: Restart count:",
                    'wmr200_write_cannot_send_usb': "weewx\.drivers\.wmr200: _write_cmd() Unable to send USB cmd:",
                    'wmr200_bogus_packet': "weewx\.drivers\.wmr200: Discarding bogus packet:",
                    'wmr200_out_of_order_rec': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record that presented out-of-order;",
                    'wmr200_archive_int_exceed': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record exceeding archive interval cnt:",
                    'wmr200_rec_before_time': "weewx\.drivers\.wmr200: genStartup() Discarding received archive record before time requested cnt:",
                    'wmr200_exit_archive_packets_queued': "weewx\.drivers\.wmr200: Exiting with packets still in archive queue cnt:",
                    'wmr200exit_live_packets_queued': "weewx\.drivers\.wmr200: Exiting with packets still in live queue cnt:"
                }
            },
            'wmr300': {
                'wmr300_history_cleared': "weewx\.drivers\.wmr300: History clear completed in",
                'wmr300_no_loop_in_hbeat_interval': "weewx\.drivers\.wmr300: No loop data in heartbeat interval,  restarting",
                'errors': {
                    'wmr300_comm_attempt_fail': "weewx\.drivers\.wmr300: init_comm: failed attempt \d+ of \d+:",
                    'wmr300_init_history_attempt_fail': "weewx\.drivers\.wmr300: init_history: failed attempt \d+ of \d+:",
                    'wmr300_fin_history_attempt_fail': "weewx\.drivers\.wmr300: finish history failed attempt \d+ of \d+:",
                    'wmr300_history_index_not_set': "weewx\.drivers\.wmr300: read history skipped: index has not been set",
                    'wmr300_history_bad_index': "weewx\.drivers\.wmr300: read history failed: bad index:",
                    'wmr300_missing_rec': "weewx\.drivers\.wmr300: missing record: skipped from",
                    'wmr300_bogus_history_rec_index': "weewx\.drivers\.wmr300: Bogus historical record index:",
                    'wmr300_get_history_unex_packet': "weewx\.drivers\.wmr300: get_history: unexpected packet, content:",
                    'wmr300_get_history_decode_error': "weewx\.drivers\.wmr300: get_history: ",
                    'wmr300_history_loop pkts_ignored': "weewx\.drivers\.wmr300: During history read, \d+ loop data packets were ignored",
                    'wmr300_history_bogus_entries': "weewx\.drivers\.wmr300: During history read, \d+ bogus entries found from",
                    'wmr300_excess_hbeat_delay': "weewx\.drivers\.wmr300: Excessive heartbeat delay: \d+s, restarting",
                    'wmr300_genlooppackets': "weewx\.drivers\.wmr300: genLoopPackets: ",
                    'wmr300_rain_counter_at_max': "weewx\.drivers\.wmr300: rain counter at maximum, reset required",
                    'wmr300_rain_counter_warning': "weewx\.drivers\.wmr300: rain counter is above warning level, reset recommended",
                    'wmr300_bad_interval': "weewx\.drivers\.wmr300: ignoring record: bad interval",
                    'wmr300_rain_ctr_dec': "weewx\.drivers\.wmr300: rain counter decrement detected:",
                    'wmr300_poss_missed_rain_event': "weewx\.drivers\.wmr300: possible missed rain event:",
                    'wmr300_rel_iface_fail': "weewx\.drivers\.wmr300: Release interface failed:",
                    'wmr300_read': "weewx\.drivers\.wmr300: read: "
                }
            },
            'ws1': {
                'ws1_readings_max_retries': "weewx\.drivers\.ws1: Max retries \(\d+\) exceeded for readings",
                'ws1_retry_conn': "weewx\.drivers\.ws1: Retrying connection...",
                'ws1_conn_max_retries': "weewx\.drivers\.ws1: Max tries (%d) exceeded for connection.",
                'errors': {
                    'ws1_decode_fail': "weewx\.drivers\.ws1: decode failed for",
                    'ws1_readings_attempt_fail': "weewx\.drivers\.ws1: Failed attempt \d+ of \d+ to get readings:",
                    'ws1_cannot_create_socket': "weewx\.drivers\.ws1: Cannot create socket for some reason:",
                    'ws1_cannot_conn': "weewx\.drivers\.ws1: Cannot connect to",
                    'ws1_cannot_close_conn': "weewx\.drivers\.ws1: Cannot close connection to",
                    'ws1_get_data_fail': "weewx\.drivers\.ws1: Failed to get data. Reason:"
                }
            },
            'ws23xx': {
                'ws23xx_conn_changed': "weewx\.drivers\.ws23xx: connection changed from",
                'ws23xx_exceed_loop_retries': "weewx\.drivers\.ws23xx: Max retries \(\d+\) exceeded for LOOP data",
                'ws23xx_set_station_clock': "weewx\.drivers\.ws23xx: setting station clock to",
                'ws23xx_set_hware_interval': "weewx\.drivers\.ws23xx: setting hardware archive interval to \d+ minutes",
                'ws23xx_clear_memory': "weewx\.drivers\.ws23xx: clearing console memory",
                'errors': {
                    'ws23xx_loop_attempt_fail': "weewx\.drivers\.ws23xx: Failed attempt \d+ of \d+ to get LOOP data:",
                    'ws23xx_invalid_wind_speed': "weewx\.drivers\.ws23xx: invalid wind reading: speed="
                }
            },
            'ws28xx': {
                'ws28xx_cannot_find_device': "weewx\.drivers\.ws28xx: Cannot find USB device with Vendor=",
                'ws28xx_adjusted_freq': "weewx\.drivers\.ws28xx: adjusted frequency:",
                'errors': {
                    'ws28xx_no_contact': "weewx\.drivers\.ws28xx: no contact with console",
                    'ws28xx_no_hist_tries': "weewx\.drivers\.ws28xx: No historical data after",
                    'ws28xx_no_data': "weewx\.drivers\.ws28xx: No data after \d+ seconds",
                    'ws28xx_unknown_freq': "weewx\.drivers\.ws28xx: unknown frequency",
                    'ws28xx_bogus_date': "weewx\.drivers\.ws28xx: ToDateTime: bogus date for",
                    'ws28xx_unknown_bytes': "weewx\.drivers\.ws28xx: Bytes with unknown meaning at",
                    'ws28xx_temp_unknown_fmt': "weewx\.drivers\.ws28xx: setTemps: unknown temperature format",
                    'ws28xx_temp_out_of_range': "weewx\.drivers\.ws28xx: setTemps: one or more values out of range",
                    'ws28xx_hum_out_of_range': "weewx\.drivers\.ws28xx: setHums: one or more values out of range",
                    'ws28xx_rain_unknown_fmt': "weewx\.drivers\.ws28xx: setRain24: unknown format",
                    'ws28xx_rain_out_of_range': "weewx\.drivers\.ws28xx: setRain24: value outside range",
                    'ws28xx_gust_unknown_fmt': "weewx\.drivers\.ws28xx: setGust: unknown format",
                    'ws28xx_gust_wrong_units': "weewx\.drivers\.ws28xx: setGust: only units of km/h are supported",
                    'ws28xx_gust_out_of_range': "weewx\.drivers\.ws28xx: setGust: value outside range",
                    'ws28xx_rel_press_unknown_fmt': "weewx\.drivers\.ws28xx: setPresRel: unknown format",
                    'ws28xx_rel_press_out_of_range': "weewx\.drivers\.ws28xx: setPresRel: value outside range",
                    'ws28xx_cannot_claim_usb': "weewx\.drivers\.ws28xx: Unable to claim USB interface",
                    'ws28xx_inbufcs_not_match': "weewx\.drivers\.ws28xx: handleCurrentData: inBufCS of station does not match",
                    'ws28xx_outbufcs_changed': "weewx\.drivers\.ws28xx: handleCurrentData: outBufCS of station changed",
                    'ws28xx_history_too_many_reqs': "weewx\.drivers\.ws28xx: handleHistoryData: too many records requested",
                    'ws28xx_history_index_mismatch': "weewx\.drivers\.ws28xx: handleHistoryData: index mismatch:",
                    'ws28xx_attempting_to_pair': "weewx\.drivers\.ws28xx: generateResponse: console not paired, attempting to pair to",
                    'ws28xx_unknown_device_id': "weewx\.drivers\.ws28xx: message from console contains unknown device ID",
                    'ws28xx_cannot_terminate_rf_thread': "weewx\.drivers\.ws28xx: unable to terminate RF thread after \d+ seconds",
                    'ws28xx_dorf_exception': "weewx\.drivers\.ws28xx: exception in doRF:",
                    'ws28xx_gen_response_fail': "weewx\.drivers\.ws28xx: generateResponse failed:"
                }
            }
        },
    },
    'report': {
        'summary': [
            {'weewxd_startups': 'engine: startups'},
            {'zz_weewxd_restarts': 'engine: restarts'},
            {'weewxd_hup_restarts': 'engine: restart from hup'},
            {'weewxd_sig_term': 'engine: restart from SIGTERM'},
            {'weewxd_keyboard_interrupt': 'engine: keyboard interrupts'},
            {'weewxd_unex_main_loop_exit': 'Unexpected exit from main loop'},
            {'weewxd_unrecoverable': 'Unrecoverable exceptions'},
            {'weewxd_recovery_attempts': 'Recovery attempts'},
            {'engine_garbage': 'engine: garbage collected'},
            {'manager_archive_records_added': 'archive: records added'},
            {'manager_summary_records_added': 'daily summaries: records added'},
            {'cheetah_generated': 'cheetahgenerator: files generated'},
            {'images_generated': 'imagegenerator: files generated'},
            {'copy_copied': 'copygenerator: files copied'},
            {'ftp_uploads': 'ftp: files uploaded'},
            {'ftp_fails': 'ftp: failures'},
            {'rsync_uploads': 'rsync: files uploaded'},
            {'rsync_fails': 'rsync: failures'},
            {'vantage_clock_set': 'vantage: times clock was set'}
        ],
        'itemised': [
            {
                'weewxd': {
                    'label': "WeeWX",
                    'items': [
                        {'weewxd_startups': "Engine startups"},
                        {'weewxd_hup_restarts': "Engine restarts"},
                        {'weewxd_sig_term': "__main__: Received signal TERM \(15\)"},
                        {'weewxd_keyboard_interrupt': "Keyboard interrupts"},
                        {'weewxd_unex_main_loop_exit': "Unexpected exit from main loop"},
                        {'weewxd_unrecoverable': "Caught unrecoverable exception"},
                        {'weewxd_recovery_attempts': "Recovery attempts"}
                    ],
                    'errors': {
                        'label': 'Errors/warnings',
                        'items': [
                            {'weewxd_unable_load_driver': "Unable to load driver"},
                            {'weewxd_io_error': "WeeWxIOError"},
                            {'weewxd_dbase_conn_exception': "Database connection exception"},
                            {'weewxd_dbase_operational_error_exception': "Database OperationalError exception"},
                            {'weewxd_os_error': "OSError"}
                        ]
                    },
                }
            },
            {
                'engine': {
                    'label': "WeeWX engine",
                    'items': [
                        {'engine_garbage': 'engine: garbage collected'},
                        {'engine_unable_launch_rep_thread': "Unable to launch report thread"},
                        {'engine_unable_shut_rep_thread': "Unable to shut down report thread"}
                    ],
                    'errors': {
                        'label': "Errors/warnings",
                        'items': [
                            {'engine_driver_import_fail': "Import of driver failed"},
                            {'engine_packet_loop_exit': "Packet loop exited"},
                            {'engine_stdcal_loop_error': "StdCalibration loop error"},
                            {'engine_stdcal_archive_error': "StdCalibration archive error"},
                            {'engine_archive_int_error': "Archive interval config/hardware mismatch"},
                            {'engine_unknown_rec_gen': "Unknown type of record generation"},
                            {'engine_archive_delay_long': "Archive delay is unusually long"},
                            {'engine_ignore_hist_rec': "Historical records ingored"},
                            {'engine_catchup_error': "Internal error, catchup abandoned"},
                            {'engine_read_time_error': "Error reading time"},
                            {'engine_rep_thread_running': "Report thread launch aborted (existing report thread still running)"},
                            {'engine_prev_rep_thread_running': "Report thread launched desite previous report thread still running"}
                        ]
                    },
                }
            },
            {
                'manager': {
                    'label': 'Archive',
                    'items': [
                        {'manager_cannot_open_db_no_schema': "Cannot open database and no schema specified"},
                        {'manager_rec_null_time': "Archive records with null time encountered"},
                        {'manager_archive_records_added': "Records added to archive table"},
                        {'manager_summary_records_added': "Records added to daily summary tables"},
                        {'manager_drop_summaries': "Daily summaries dropped"}
                    ],
                    'errors': {
                        'label': "Errors/warnings",
                        'items': [
                            {'manager_cannot_get_columns': "Cannot get columns of table"},
                            {'manager_unable_create_table': "Unable to create table"},
                            {'manager_unable_add_rec': "Unable to add record"},
                            {'manager_replace_failed': "Replace failed for database"},
                            {'manager_drop_summaries_fail': "Failed to drop daily summary tables"}
                        ],
                    }
                }
            },
            {
                'reportengine': {
                    'label': "Report engine",
                    'items': [
                        {'reportengine_ignored': "Reports ignored"},
                        {'reportengine_report_timing_skipped': "Reports skipped due to report_timing"},
                        {'report_engine_generator_ignored': "Generators ignored"},
                        {'report_engine_generator_terminated': "Generators terminated"},
                    ],
                    'errors': {
                        'label': 'Errors',
                        'items': [
                            {'reportengine_invalid_report_timing': "Invalid report_timing setting"},
                            {'reportengine_cannot_instantiate_gen': "Unable to instantiate generator"},
                            {'reportengine_unrecov_exception_gen': "Caught unrecoverable exception in generator"},
                            {'reportengine_cannot_read_skin_conf': "Cannot read skin configuration file"},
                            {'reportengine_failed_read_skin_conf': "Failed to read skin configuration file"},
                        ]
                    },
                }
            },
            {
                'cheetah_generator': {
                    'label': "Cheetah generator",
                    'items': [
                        {'cheetah_generated': "Files generated"}
                    ]
                }
            },
            {
                'image_generator': {
                    'label': "Image generator",
                    'items': [
                        {'images_generated': "Images generated"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'image_gen_agg_errors': "Aggregate interval missing"},
                            {'image_gen_gap_frac': "Gap fraction outside range"},
                            {'image_gen_unable_save_file': "Unable to save to file"}
                        ]
                    }
                }
            },
            {
                'copy_generator': {
                    'label': "Copy generator",
                    'items': [
                        {'copy_copied': "Files copied"}
                    ]
                }
            },
            {
                'ftp_generator': {
                    'label': "FTP generator",
                    'items': [
                        {'ftp_uploads': "Files uploaded"},
                        {'ftp_fails': "Failed uploads"}
                    ],
                    'errors': {
                        'label': 'Errors',
                        'items': [
                            {'ftp_exception': "Exceptions caught"},
                            {'ftp_connect_fail_attempt': "Failed server connection attempts"},
                            {'ftp_connect_fail': "Failed server connections"},
                            {'ftp_upload_fail_attempt': "Failed upload attempts"},
                            {'ftp_make_dir_error': "Errors received while creating remote directory"},
                            {'ftp_make_dir_fail': "Failed attempts to create remote directory"}
                        ]
                    }
                }
            },
            {
                'rsync_generator': {
                    'label': "RSYNC generator",
                    'items': [
                        {'rsync_executed': "RSYNC sessions"},
                        {'rsync_files_uploaded': "Files processed"}
                    ],
                    'errors': {
                        'label': 'Errors',
                        'items': [
                            {'rsync_exception': "Exceptions caught"},
                            {'rsync_errors': "RSYNC sessions with errors"}
                        ]
                    }
                }
            },
            {
                'qc': {
                    'label': "Quality control service",
                    'items': [
                        {'qc_no_config': "No quality control information in config file"}
                    ]
                }
            },
            {
                'restx': {
                    'label': "RESTful services",
                    'items': [
                        {'restx_published': "Records published"},
                        {'restx_skipped': "Records skipped"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'restx_upload_errors': "Failed to upload"},
                            {'restx_shut_thread_fail': "Unable to shutdown thread"},
                            {'restx_db_error': "Database operational error"},
                            {'restx_bad_login_wait': "Bad login (waiting)"},
                            {'restx_bad_login_terminate': "Bad login (no retry)"},
                            {'restx_bad_cert_wait': "Bad SSL certificate"},
                            {'restx_bad_cert_terminate': "Bad SSL certificate (no retry)"},
                            {'restx_unexpect_exception': "Unexpected exception"},
                            {'restx_thread_terminate': "Thread terminating"},
                            {'restx_upload_attempt_fail': "Failed upload attempt"},
                            {'restx_bad_server': "Bad server address:"},
                            {'restx_connection_error_attempt': "Connection error"},
                            {'restx_socket_error_attempt': "Socket send error"},
                            {'restx_response_exception': "Exception when looking for response"},
                            {'restx_no_station_url': "No station URL specified"},
                            {'restx_missing_config': "No config info"},
                            {'restx_missing_option': "Missing option"}
                        ]
                    }
                }
            },
            {
                'general': {
                    'label': "General",
                    'items': [
                        {'wxservices_et_mixed_units': "Mixed unit system in evapotranspiration calculation"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'units_cannot_convert': "Unable to convert"},
                            {'wxformulas_rain_counter_reset': "Rain counter reset detected"},
                            {'wxservices_unknown_extens_type': "Unknown extensible type"},
                            {'wxservices_unknown_agg': "Unknown aggregation"},
                            {'wxservices_et_failed': "Calculation of evapotranspiration failed"},
                            {'wxservices_db_error_rainrate': "Database error while initializing rainRate"}
                        ]
                    }
                }
            },
            {
                'fixes': {
                    'label': "Fixes",
                    'items': [
                        {'maxwindspeed_fix_applied': "Maximum windSpeed fix applied"},
                        {'db_interval_weight_applied': "Interval weighting fix applied"}
                    ],
                    'errors': {
                        'label': "Errors/warnings",
                        'items': [
                            {'maxwindspeed_fix_fail': "Maximum windSpeed fix not applied"},
                            {'db_interval_weight_not_applied': "Interval weighting fix not applied"},
                            {'db_interval_weight_fix_fail': "Interval weighting fix failed"}
                        ]
                    }
                }
            },
            {
                'acurite': {
                    'label': "Acurite",
                    'items': [
                        {'acurite_loop_max_tries_error': "Maximum retries to get LOOP data exceeded"},
                        {'acurite_rain_count_dec': "Rain counter decrement ignored"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'acurite_fail_loop_attempt': "Failed attempts to get LOOP data"},
                            {'acurite_r3_read_fail': "R3 read failed"},
                            {'acurite_cannot_find_device': "Cannot find USB device"},
                            {'acurite_cannot_claim_usb': "Unable to claim USB interface"},
                            {'acurite_iface_release_fail': "Interface release failed"},
                            {'acurite_r1_bad_length': "R1 bad length"},
                            {'acurite_r1_bad_format': "R1 bad format"},
                            {'acurite_r1_no_sensors': "R1 no sensors found"},
                            {'acurite_r1_bogus_flavor': "R1 bogus message flavor"},
                            {'acurite_r1_bogus_final_byte': "R1 bogus final byte"},
                            {'acurite_r2_bad_length': "R2 bad length"},
                            {'acurite_r2_bad_format': "R2 bad format"},
                            {'acurite_r2_unknown_cal': "R2 unknown calibration constants"},
                            {'acurite_r2_const_changed': "R2 constants changed"},
                            {'acurite_r3_bad_value': "R3 bad value in row"},
                            {'acurite_r3_bad_length': "R3 bad length in row"},
                            {'acurite_r3_bad_format': "R3 bad format in row"}
                        ]
                    }
                }
            },
            {
                'cc3000': {
                    'label': "CC3000",
                    'items': [
                        {'cc3000_mem_usage_fail': "Unable to determine memory usage"},
                        {'cc3000_cleared_memory': "Cleared all records from logger"},
                        {'cc3000_max_retries': "Exceeded maximum tries to get data"},
                        {'cc3000_no_sensor_data': "No data from sensors"},
                        {'cc3000_set_time': "Station time set"},
                        {'cc3000_set_dst': "Daylght saving set"},
                        {'cc3000_set_units': "Units set"},
                        {'cc3000_set_log_interval': "Logging interval set"},
                        {'cc3000_set_channel': "Channel set"},
                        {'cc3000_set_baro_offset': "Barometer offset set"},
                        {'cc3000_reset_max': "Reset maximum values"},
                        {'cc3000_reset_min': "Reset minimum values"},
                        {'cc3000_mem_clear': "Station memory cleared"},
                        {'cc3000_reset_rain': "Rain counter reset"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'cc3000_get_data_fail_attempt': "Failed attempts to get data"},
                            {'cc3000_gettime_fail': "Failed to get station time"},
                            {'cc3000_init_fail_attempt': "Failed attempts to initialize station"},
                            {'cc3000_val_hdr_mismatch': "Values/header mismatch"},
                            {'cc3000_parse_fail': "Parse failed"},
                            {'cc3000_echo_timeout': "Reading command echo timed out"},
                            {'cc3000_retry_fail': "Command retry failed"},
                            {'cc3000_unexpected_rec': "Unexpected record"}
                        ]
                    }
                }
            },
            {
                'fousb': {
                    'label': "FineOffset USB",
                    'items': [
                        {'fousb_read_block_change': "USB check: Bad reads"},
                        {'fousb_rain_count_dec': "Spurious rain counter decrements ignored"},
                        {'fousb_rain_count_wrap': "Rain counter wrap arounds"},
                        {'fousb_power_cycles_attempted': "Power cycles attempted"},
                        {'fousb_power_cycles_completed': "Power cycles completed"},
                        {'fousb_sync_to_station': "Synchronised to station"},
                        {'fousb_unex_sensor_clk_change': "Unexpected sensor clock change"},
                        {'fousb_setting_sensor_clk': "Sensor clock set"},
                        {'fousb_missed_interval': "Missed interval"},
                        {'fousb_unexpected_clock_change': "Unexpected station clock change"},
                        {'fousb_setting_stn_clk': "Station clock set"},
                        {'fousb_lost_log_sync': "Lost log synchronisation"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'fousb_get_interval_fail': "Failed attempts to get archive interval"},
                            {'fousb_cannot_find_device': "Cannot find USB device"},
                            {'fousb_cannot_claim_usb': "Unable to claim USB interface"},
                            {'fousb_station_status': "Station status changes"}, # leave out and just display lines ?
                            {'fousb_get_obs_fail': "Failed to get observations"},
                            {'fousb_invalid_data': "Invalid data in records from station memory"},
                            {'fousb_get_rec_fail': "Failed to get records from station memory"},
                            {'fousb_invalid_data_while_sync': "Invalid delay while synchronising"},
                            {'fousb_lost_sync': "Lost synchronisation"},
                            {'fousb_unex_ptr_change': "Unexpected pointer change"},
                            {'fousb_changing_format': "Changing data format"},
                            {'fousb_unstable_read': "Unstable read"},
                            {'fousb_unrecog_magic_number': "Unrecognised magic number"},
                            {'fousb_magic_num_changed': "Magic number changed"}
                        ]
                    }
                }
            },
            {
                'te923': {
                    'label': "TE923",
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'te923_skip_dupe_ts': "Packets with duplicate timestamps skipped"},
                            {'te923_cannot_find_device': "Cannot find USB device"},
                            {'te923_cannot_claim_usb': "Unable to claim USB interface"},
                            {'te923_rel_iface_fail': "Interface release failed"},
                            {'te923_read_timeout': "Timeout while reading raw data"},
                            {'te923_wrong_num_bytes': "Read: wrong number of bytes"},
                            {'te923_write_wrong_bytes': "Write: acknowledgement got wrong number of bytes"},
                            {'te923_read_data_fail': "Failed attempts to read data"},
                            {'te923_write_data_fail': "Failed attempts to write data"},
                            {'te923_unrecog_mem_size': "Unrecognised memory size"},
                            {'te923_rec_index_exceeds_mem': "Record index exceeds memory size"},
                            {'te923_too_many_rec': "Too many records requested"},
                            {'te923_gen_rec_skip': "Generate records, record skipped"},
                            {'te923_no_data_at_add': "Get record, no data at address"},
                            {'te923_unrecog_interval': "Unrecognized archive interval"}
                        ]
                    }
                }
            },
            {
                'ultimeter': {
                    'label': "Ultimeter",
                    'items': [
                        {'ultimeter_set_time': "Set station time"},
                        {'ultimeter_set_year': "Set station year"},
                        {'ultimeter_set_logger_mode': "Set station to logger mode"},
                        {'ultimeter_set_modem_mode': "Set station to modem mode"},
                        {'ultimeter_readings_max_retries': "Maximum retries to get readings exceeded"},
                        {'acurite_rain_count_dec': "Rain counter decrement ignored"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'ultimeter_get_time_fail': "Failed to get time"},
                            {'ultimeter_get_readings_fail': "Failed attempts to get readings"},
                            {'ultimeter_decode_fail': "Decode failed"}
                        ]
                    }
                }
            },
            {
                'vantage': {
                    'label': "Vantage",
                    'items': [
                        {'vantage_wakeup_fail': "Failure to wake up console"},
                        {'vantage_no_ack': "No acknowledgement received from console"},
                        {'vantage_send_crc_fail': "Unable to pass CRC16 check while sending data"},
                        {'vantage_send_cmd_max_retries': "Max retries exceeded while sending command"},
                        {'vantage_get_crc_fail': "Unable to pass CRC16 check while getting data"},
                        {'vantage_crc_timeout': "Timeout in while getting data with CRC"},
                        {'vantage_loop_max_tries_error': "Max retries exceeed while reading Loop data"},
                        {'vantage_dmpaft_max_ties': "Max retries exceeded while reading DMPAFT data"},
                        {'vantage_get_time_max_tries': "Max retries exceeded while getting time"},
                        {'vantage_set_time': "Console time set"},
                        {'vantage_set_time_max_tries': "Max retries exceeded while setting time"},
                        {'vantage_cup_set': "Wind cup type set"},
                        {'vantage_bucket_set': "Rain bucket type set "},
                        {'vantage_rain_year_set': "Rain year start set"},
                        {'vantage_barometer_cal_set': "Barometer calibration set"},
                        {'vantage_lat_set': "Station latitude set"},
                        {'vantage_long_set': "Station longitude set"},
                        {'vantage_interval_set': "Archive interval set"},
                        {'vantage_lamp_set': "Lamp set"},
                        {'vantage_trans_type_set': "Transmitter type set for channel"},
                        {'vantage_retrans_set': "Retransmit set"},
                        {'vantage_console_temp_log_set': "Console temperature logging set"},
                        {'vantage_wind_cal_set': "Wind calibration set"},
                        {'vantage_temp_cal_set': "Temperature calibration set"},
                        {'vantage_hum_cal_set': "Humidity calibration set"},
                        {'vantage_archive_mem_clear': "Archive memory cleared"},
                        {'vantage_clear_log_max_tries': "Max retries exceeded while clearing log"},
                        {'vantage_inconsist_eeprom': "Inconsistent EEPROM calibration values"},
                        {'vantage_hardware_type_no_read': "Unable to read hardware type"},
                        {'vantage_eeprom_max_tries': "Max retries exceeded while getting EEPROM data"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'vantage_serial_exception_read': "Serial exception on read"},
                            {'vantage_serial_exception_write': "Serial exception on write"},
                            {'vantage_socket_error': "Socket error while opening port"},
                            {'vantage_eth_no_conn': "Unable to connect to ethernet host"},
                            {'vantage_ip_read_error': "IP read error"},
                            {'vantage_ip_write_error': "IP write error"},
                            {'vantage_loop_try_error': "Retries while reading Loop data"},
                            {'vantage_dmpaft_try_error': "DMPAFT try error"},
                            {'vantage_unknown_bucket': "Unknown bucket type"},
                            {'vantage_unknown_loop': "Unknown LOOP packet type"}
                        ]
                    }
                }
            },
            {
                'wmr9x8': {
                    'label': "WMR9x8",
                    'items': [
                        {'wmr9x8_rx_wm918_data_packet': "WM-918 data packets received"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'wmr9x8_invalid_packet': "Invalid data packet"}
                        ]
                    }
                }
            },
            {
                'wmr100': {
                    'label': "WMR100",
                    'items': [
                        {'wmr100_usb_report_max_retries': "Max retries exceeded while fetching USB reports"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'wmr100_cannot_find_device': "Cannot find device"},
                            {'wmr100_cannot_claim_usb': "Unable to claim USB interface"},
                            {'wmr100_malformed_packet': "Malformed packet"},
                            {'wmr100_checksum_exception': "Exception while calculating checksum"},
                            {'wmr100_buffer_length_bad checksum': "Bad checksum on buffer"},
                            {'wmr100_unable_send_usb_ctl': "Unable to send USB control message"},
                            {'wmr100_bad_usb_report': "Bad USB report received"}
                        ]
                    }
                }
            },
            {
                'wmr200': {
                    'label': "WMR200",
                    'items': [
                        {'wmr200_device_not_spec': "Device not specified"},
                        {'wmr200_no_usb_handle_read': "No USB handle for device"},
                        {'wmr200_usb_overflow': "Overflow error when reading USB device"},
                        {'wmr200_no_usb_handle_write': "No USB handle for device write"},
                        {'wmr200_size_fail': "Failed to extract size from packet"},
                        {'ws1_conn_max_retries': "Maximum tries to connect exceeded"},
                        {'wmr200_packet_too_small_comp_crc': "Packet too small to compute checksum"},
                        {'wmr200_packet_too_small_cont_crc': "Packet too small to contain checksum"},
                        {'wmr200_timestamp_not_set': "Timestamp not set in record"},
                        {'wmr200_cooked_before_setup': "print_cooked() called before proper setup"},
                        {'wmr200_invalid_time_drift': "Invalid time drift used"},
                        {'wmr200_device_unresponsive': "Device unresponsive after multiple resets"},
                        {'wmr200_usb_read_error': "USB device read error"},
                        {'wmr200_reset_console': "Reset console device"},
                        {'wmr200_cannot_find_device': "Unable to find device"},
                        {'wmr200_usb_poll_thread_term': "USB polling thread unexpectedly terminated"},
                        {'wmr200_ignore_rec': "Ignoring received archive record before requested timestamp"},
                        {'wmr200_usb_poll_thread_alive': "USB polling thread still alive"},
                        {'wmr200_wdog_thread_alive': "Watchdog thread still alive"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'wmr200_cannot_open_usb': "Unable to open USB interface"},
                            {'wmr200_cannot_claim_usb': "Unable to claim USB interface"},
                            {'wmr200_cannot_release_iface': "Unable to release device interface"},
                            {'wmr200_index_range_fail': "Failed index range on read"},
                            {'wmr200_usb_read_error': "USB error on read"},
                            {'wmr200_write_cannot_send_usb_control': "Unable to send USB control message"},
                            {'wmr200_unexpected_packet_size': "Unexpected packet size"},
                            {'wmr200_no_get_key': "Record get key not found"},
                            {'wmr200_no_set_key': "Record set key not found"},
                            {'wmr200_record_update_fail': "Record update failed"},
                            {'wmr200_checksum_miscompare': "Checksum miscompare"},
                            {'wmr200_cannot_get_timestamp': "Packet length too short to get timestamp"},
                            {'wmr200_sensor_packet': "Sensor packet status received"},
                            {'wmr200_index_decode_index_fail': "Decode index failure"},
                            {'wmr200_pressure_unknown': "Pressure unknown nibble"},
                            {'wmr200_reset_cannot_send_usb_control': "Unable to send USB control"},
                            {'wmr200_unverified_interval': "weewx\.drivers\.wmr200: Unverified archive interval:"},
                            {'wmr200_restart_count': "Restart stat count"},
                            {'wmr200_write_cannot_send_usb': "Unable to send USB command"},
                            {'wmr200_bogus_packet': "Discarded bogus packets"},
                            {'wmr200_out_of_order_rec': "Discarding received archive record that presented out of order"},
                            {'wmr200_archive_int_exceed': "Discarding received archive record exceeding archive interval"},
                            {'wmr200_interval_zero': "Discarding received archive record as interval is zero"},
                            {'wmr200_rec_before_time': "Discarding received archive record before time requested"},
                            {'wmr200_exit_archive_packets_queued': "Exiting with packets still in archive queue"},
                            {'wmr200exit_live_packets_queued': "Exiting with packets still in live queue"}
                        ]
                    }
                }
            },
            {
                'wmr300': {
                    'label': "WMR300",
                    'items': [
                        {'wmr300_history_cleared': "History cleared"},
                        {'wmr300_no_loop_in_hbeat_interval': "No loop data in heartbeat interval"},
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'wmr300_comm_attempt_fail': "Failed attempts to initiate communication"},
                            {'wmr300_init_history_attempt_fail': "Failed attempts to initiate history streaming"},
                            {'wmr300_fin_history_attempt_fail': "Failed attempt to finish history streaming"},
                            {'wmr300_history_index_not_set': "Read history skipped - index has not been set"},
                            {'wmr300_history_bad_index': "Read history failed - bad index"},
                            {'wmr300_missing_rec': "Missing history record"},
                            {'wmr300_bogus_history_rec_index': "Bogus history record index"},
                            {'wmr300_get_history_unex_packet': "Unexpected history packet content"},
                            {'wmr300_get_history_decode_error': "Get history decode errors"},
                            {'wmr300_history_loop pkts_ignored': "Loop packets ignored during history read",},
                            {'wmr300_history_bogus_entries': "Bogus entries found during history read"},
                            {'wmr300_excess_hbeat_delay': "Excessive heartbeat delay"},
                            {'wmr300_genlooppackets': "genLoopPackets decode/protocol errors"},
                            {'wmr300_rain_counter_at_max': "Rain counter reset required"},
                            {'wmr300_rain_counter_warning': "Rain counter reset recommended"},
                            {'wmr300_bad_interval': "Ignored records - bad interval"},
                            {'wmr300_rain_ctr_dec': "Rain counter decrements detected"},
                            {'wmr300_poss_missed_rain_event': "Possible missed rain events"},
                            {'wmr300_rel_iface_fail': "Release interface failed"},
                            {'wmr300_read': "Read USB errors"},
                        ]
                    }
                }
            },
            {
                'ws1': {
                    'label': "WS1",
                    'items': [
                        {'ws1_readings_max_retries': "Maximum retries to get readings exceeded"},
                        {'ws1_retry_conn': "Connection retries"},
                        {'ws1_conn_max_retries': "Maximum tries to connect exceeded"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'ws1_decode_fail': "Decode failed"},
                            {'ws1_readings_attempt_fail': "Failed attempts to get readings"},
                            {'ws1_cannot_create_socket': "Cannot create socket"},
                            {'ws1_cannot_conn': "Failed attempt connect"},
                            {'ws1_cannot_close_conn': "Cannot close connection"},
                            {'ws1_get_data_fail': "Failed to get data"}
                        ]
                    }
                }
            },
            {
                'ws23xx': {
                    'label': "WS23XX",
                    'items': [
                        {'ws23xx_conn_changed': "Connection changed"},
                        {'ws23xx_exceed_loop_retries': "Exceeded maximum tries to get LOOP data"},
                        {'ws23xx_set_station_clock': "Station clock set"},
                        {'ws23xx_set_hware_interval': "Hardware archive interval set"},
                        {'ws23xx_clear_memory': "Clear console memory"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'ws23xx_loop_attempt_fail': "Failed attempts to get LOOP data"},
                            {'ws23xx_invalid_wind_speed': "Invalid wind reading"}
                        ]
                    }
                }
            },
            {
                'ws28xx': {
                    'label': "WS28XX",
                    'items': [
                        {'ws28xx_cannot_find_device': "Cannot find USB device"},
                        {'ws28xx_adjusted_freq': "Adjusted frequency"}
                    ],
                    'errors': {
                        'label': "Errors",
                        'items': [
                            {'ws28xx_no_contact': "No contact with console"},
                            {'ws28xx_no_hist_tries': "Failed to obtain historical data"},
                            {'ws28xx_no_data': "Timeout obtaining historical data"},
                            {'ws28xx_unknown_freq': "Unknown frequency"},
                            {'ws28xx_bogus_date': "Bogus date"},
                            {'ws28xx_unknown_bytes': "Bytes with unknown meaning"},
                            {'ws28xx_temp_unknown_fmt': "Unknown temperature format"},
                            {'ws28xx_temp_out_of_range': "Temperature value out of range"},
                            {'ws28xx_hum_out_of_range': "Humidity value out of range"},
                            {'ws28xx_rain_unknown_fmt': "Unknown rain format"},
                            {'ws28xx_rain_out_of_range': "Rain value outside range"},
                            {'ws28xx_gust_unknown_fmt': "Unknown gust format"},
                            {'ws28xx_gust_wrong_units': "Unknown gust units"},
                            {'ws28xx_gust_out_of_range': "Gust value outside range"},
                            {'ws28xx_rel_press_unknown_fmt': "Unknown relative pressure format"},
                            {'ws28xx_rel_press_out_of_range': "Relative pressure value outside range"},
                            {'ws28xx_cannot_claim_usb': "Unable to claim USB interface"},
                            {'ws28xx_inbufcs_not_match': "inBufCS of station does not match"},
                            {'ws28xx_outbufcs_changed': "outBufCS of station changed"},
                            {'ws28xx_history_too_many_reqs': "Too many history data records requested"},
                            {'ws28xx_history_index_mismatch': "History data index mismatch"},
                            {'ws28xx_attempting_to_pair': "Console not paired"},
                            {'ws28xx_unknown_device_id': "Unknown device ID"},
                            {'ws28xx_cannot_terminate_rf_thread': "Unable to terminate RF thread"},
                            {'ws28xx_dorf_exception': "Exception in doRF()"},
                            {'ws28xx_gen_response_fail': "generateResponse() failed"}
                        ]
                    }
                }
            }
        ]
    }
}

# Define the summary report items to be reported for different logwatch
# --detail values. Python dict keyed by an integer >=0 and <=10. Each key
# value is a tuple of strings with each string being the name of a summary
# report item to be displayed. There must be an entry for key = 0.
WEEWX_SUMMARY_LEVELS = {0: ('weewxd_startups', 'zz_weewxd_restarts',
                            'weewxd_hup_restarts', 'weewxd_sig_term',
                            'weewxd_keyboard_interrupt',
                            'weewxd_unex_main_loop_exit', 'weewxd_unrecoverable',
                            'weewxd_recovery_attempts', 'engine_garbage',
                            'manager_archive_records_added',
                            'manager_summary_records_added', 'cheetah_generated',
                            'images_generated', 'copy_copied', 'ftp_uploads',
                            'ftp_fails', 'rsync_uploads', 'rsync_fails',
                            'vantage_clock_set'),
                        5: ('weewxd_startups', 'zz_weewxd_restarts',
                            'weewxd_hup_restarts', 'weewxd_sig_term',
                            'weewxd_keyboard_interrupt',
                            'weewxd_unex_main_loop_exit', 'weewxd_unrecoverable',
                            'weewxd_recovery_attempts', 'engine_garbage',
                            'manager_archive_records_added',
                            'manager_summary_records_added', 'vantage_clock_set')
                        }

# locations to search for user specified logwatch config file logwatch.conf
LOCATIONS = ('/home/weewx/bin/user',
             '/usr/share/weewx/user',
             '/Users/Shared/weewx/bin')
EXT_D_LOCATIONS = ('/home/weewx', '/etc/weewx/logwatch', '/Users/Shared/weewx')


class WeeWXLogwatchEngine(object):
    """Class to control processing and reporting on WeeWX logs.

    WeeWXLogwatchEngine creates LogwatchProcessor objects to ingest WeeWX
    generated log lines and produce the WeeWX logwatch report. An instance of
    class WeeWXLogwatchProcessor is created to ingest and report on log lines
    generated by the current WeeWX code base. Additional objects based on
    class LogwatchProcessor can be defined externally to ingest and report on
    log lines produced by WeeWX extensions or other addon code.

    Log lines are accepted one line at a time and passed to known
    LogwatchProcessor objects until a regex match is found. Unmatched lines are
    recorded by WeeWXLogwatchEngine. Regex matches are recorded by the
    individual LogwatchProcessor objects.

    Once all lines have been processed the WeeWX logwatch report is generated
    by calling each known LogwatchProcessor object to contribute to the report.

    The regexes used to process log lines and the WeeWX report format can be
    controlled through a config dict used by each LogwatchProcessor based
    object. Reporting from each LogwatchProcessor object can be further
    extended with overridden/custom methods for more detailed reports.

    Class WeeWXLogwatchEngine can be called either from the logwatch system or
    directly by the user. When called directly by the user a file is used as
    the log source. If we have been called by logwatch, logwatch determines the
    lines to be passed to WeeWXLogwatchEngine based on the logwatch config and
    command line parameters.

    Level of detail. Logwatch supports a command line parameter 'detail' that
    sets the level of detail in the logwatch report. The detail parameter is a
    positive integer or high, med, low, which correspond to the integers 10,
    5, and 0, respectively. The WeeWX logwatch report uses the detail parameter
    as follows:

    0-2, low:    Clock report and summary counts only.
    3-4:         As per 0-2, low plus unmatched lines.
    5-7, medium: As per 3-4 plus itemised summaries.
    8-10, high:  As per 5-7, medium plus itemised error lines or the full
                 report.

    Input:
        logwatch_config_path: Path to WeeWX logwatch config file. Optional,
                              default is None.
        log_source: If omitted or None it is assumed that logwatch has invoked
                    WeeWXLogwatchEngine and stdin is used as the source for log
                    lines, otherwise log_source contains the path and file name
                    of a text file containing log lines to be processed.
                    Optional, default is None.
        detail:     Level of detail to include in the logwatch report. Optional,
                    positive integer 0-10 inclusive, default is 0.

    Output:
        WeeWX logwatch report sent to stdout.
    """

    def __init__(self, logwatch_config_path=None, log_source=None, detail=0):

        # record our start ts
        self.start_ts = time.time()
        # set our log source
        if log_source is None:
            # we have been invoked by logwatch so our log source is stdin
            self.log_source = sys.stdin
        else:
            # we have been invoked directly so our source will be a file like
            # object
            self.log_source = self.read_log(log_source)
        # set the level of detail required by logwatch
        self.detail = detail
        # now obtain a list of logwatch processor objects that we will use
        # first off the default WeeWX processor
        self.processor_objects = [WeeWXLogwatchProcessor(ConfigObj(WEEWX_LOGWATCH_CONFIG_DEFAULT),
                                                         WEEWX_SUMMARY_LEVELS,
                                                         self.detail), ]
        # now add any that may be in ext.d
        ext_processor_objects = self.get_processors()
        self.processor_objects += ext_processor_objects

        # obtain an overall logwatch config dict by merging the configs for all
        # processor objects
        # initialise an empty config, we will merge into it
        self.logwatch_config = ConfigObj()
        # iterate over all processor objects
        for processor in self.processor_objects:
            # get the processors config, first put it in a dict so we can find
            # it later and then make it into a ConfigObj
            processor_config = ConfigObj({processor.__class__.__name__: processor.service_config})
            # merge the resulting ConfigObj into our overall config
            self.logwatch_config.merge(processor_config)

        # initialise a list to hold unmatched lines
        self.unmatched = []

        # set up the ignore list regex, since we want unique items in our list
        # use python sets
        # start with an empty set
        _ignore_set = set()
        # iterate over each process object we are using and add any ignore list
        # that it may have
        for processor in self.processor_objects:
            _processor_ignore_set = set(processor.ingest_config.get('ignore', []))
            _ignore_set = _ignore_set.union(_processor_ignore_set)
        # initialise a list to hold all the compiled res for our ignore list
        self.ignore_regexs = []
        for check in _ignore_set:
            self.ignore_regexs.append(re.compile(check))

    def get_processors(self):
        """Find and obtain any addon logwatch processors."""

        # initialise a list hold any processor objects we find
        _processor_objects = []
        # see if we can find ext.d in one of the usual locations
        for ext in EXT_D_LOCATIONS:
            path = os.path.join(ext, 'ext.d')
            if os.path.exists(path) and os.path.isdir(path):
                break
        else:
            return _processor_objects
        # we are going to modify the path, so save the current path for
        # restoration later
        old_path = sys.path
        # now look for any processors in ext.d
        try:
            # insert the path we are using to look for addon scripts into
            # sys.path
            sys.path.insert(0, path)
            # iterate over the contents of the directory where we are looking
            # for addon scripts
            for file_name in os.listdir(path):
                # get the full path to the item
                current = os.path.join(path, file_name)
                # check if it's a file
                if os.path.isfile(current):
                    # we have a file, obtain just the name without the
                    # extension
                    base = os.path.basename(current)
                    stem = os.path.splitext(base)[0]
                    # now import the module being prepared to catch the error
                    # if the import fails
                    try:
                        __import__(stem)
                    except ImportError:
                        # inform the use and continue
                        print("could not import '%s'" % stem)
                        continue
                    # get the module object we just imported from the dict of
                    # imported modules
                    module = sys.modules[stem]
                    # now call the modules loader function which will give us
                    # an object instantiated from the addon class
                    loader = getattr(module, 'loader')
                    # add the object to our list of processor objects
                    _processor_objects.append(loader(detail=self.detail))
        finally:
            # we are done so restore the original path
            sys.path = old_path
        # return the list of processor objects we found
        return _processor_objects

    def run(self):
        """Process each line and produce our report.

        This is pretty straightforward, first ingest the log lines that logwatch
        feeds us then create the report.
        """

        # process the log lines
        self.ingest_lines()
        # produce the report
        self.generate_report()

    def ingest_lines(self):
        """Ingest each log line.

        Process each log line in turn passing it to each of the LogwatchProcessor
        objects we have until we obtain a 'match'. If the line is not matched
        add it to the unmatched list.
        """

        # iterate over all log lines from our source
        for line in self.log_source:
            # iterate over each of the processor objects we have passing the
            # line to each in turn
            for processor in self.processor_objects:
                # did we get a match from that object
                if processor.ingest_line(line) is True:
                    # we have a match, we are done so break out of the loop
                    break
            else:
                # did not find a match in any of our processor objects so is
                # this a line we can ignore?
                for ignore_regex in self.ignore_regexs:
                    if ignore_regex.search(line):
                        # yes we can ignore it, we are done so break out of the
                        # loop
                        break
                else:
                    # we did not find a match in any of our LogwatchProcessor
                    # object or the ignore list so save the line to the
                    # unmatched list for later reporting
                    self.unmatched.append(line)

    def generate_report(self):
        """Generate the WeeWX logwatch report.

        Generate the WeeWX logwatch report based upon the collected results,
        specific report requirements and the report definition in the
        [[report]] stanza in the WeeWX logwatch config.

        The clock report is specific to WeeWX and is not defined via the
        [[report]] stanza.

        Input:
            Nothing

        Output:
            The WeeWX logwatch report
        """

        # first display the WeeWX script version
        print("WeeWX logwatch script v%s" % WEEWX_LOGWATCH_VERSION)
        print()

        # now do the summary report
        is_summary_empty = True
        for processor in self.processor_objects:
            # call the generate_summary_report_method
            is_summary_empty = processor.generate_summary_report(detail=self.detail,
                                                                 is_empty=is_summary_empty)

        # now do any itemised reports but only if detail level is >= 5
        if self.detail >= 5:
            for processor in self.processor_objects:
                # call the generate_itemised_report_method
                processor.generate_itemised_report(detail=self.detail)

        # give each of the LogwatchProcessor objects the chance to provide any
        # additional report output specific to themselves but only if detail
        # level is >= 5
        if self.detail >= 5:
            for processor in self.processor_objects:
                # call their generate_additional_report() method
                processor.generate_additional_report(detail=self.detail)

        # now do the unmatched lines but only if detail >= 3
        if self.detail >= 3 and len(self.unmatched) > 0:
            print()
            print("Unmatched lines:")
            for line in self.unmatched:
                print("  %s" % (line.rstrip('\n'),))

        # finally record how long we took
        elapsed = time.time() - self.start_ts
        print()
        print("WeeWX logwatch report generated in %0.3f seconds" % elapsed)

    @staticmethod
    def get_user_logwatch_config(logwatch_config_path=None):
        """Return user defined logwatch config if it exists.

        Look for logwatch.conf in /home/weewx/bin/user and
        /usr/share/weewx/user and if found return as a ConfigObj object.
        """

        # do we have a path
        if logwatch_config_path is not None:
            return ConfigObj(logwatch_config_path,
                             file_error=True,
                             encoding="utf-8")
        else:
            # no path provided so go looking in the usual places
            for directory in LOCATIONS:
                candidate = os.path.abspath(os.path.join(directory, 'logwatch.conf'))
                # does the candidate file exist, if so return its contents as a
                # ConfigObj object
                if os.path.isfile(candidate):
                    return ConfigObj(candidate, encoding="utf-8")
        # we could not find a logwatch config file so return None
        return ConfigObj({})

    @staticmethod
    def read_log(source):
        """Read log from external file.

        For testing and development only. Delete before release.
        """

        fh = open(source)
        for line in fh:
            yield line
        fh.close()


class LogwatchProcessor(object):
    """Base class to process log files.

    Class LogwatchProcessor knows how to:
    - add regex used as filters
    - ingest a log entry line
    - generate summary and various itemised reports

    Class LogwatchProcessor is used as the base class for defining classes to
    process log entry lines from the WeeWX core code or installed add-ons. In
    many cases there will be no need to extend class LogwatchProcessor, just
    base the new class on class LogwatchProcessor and initialise it with the
    appropriate config items. The class LogwatchProcessor methods may be
    overriden, in particular the report generation methods, to handle any
    specific requirements of a particular add-on.
    """

    def __init__(self, service_config, summary_levels, detail=0):
        # save our config
        self.service_config = service_config
        # Get a tuple containing the summary report items to be displayed in
        # the generated report. The items displayed may vary with the detail
        # level. The detail level will be an integer from 0 (least detail) to
        # 10 (most detail) incl, but our possible summary report content is
        # likely defined much more coarsely.

        # first get a list of summary report levels that meet (ie do not
        # exceed) our required detail level

        # assume our result is an empty tuple
        _tuple = tuple()
        #  now try to obtain the summary report fields from our summary levels
        #  config but be prepared to catch the error if a summary levels config
        #  was not provided or is incorrectly structured
        try:
            # get a list of the detail levels defined in the summary levels
            # config and obtain the highest defined level that does not exceed
            # our detail level
            _levels = [k for k in summary_levels.keys() if k <= detail]
            key = max(_levels)
            # now we can get our tuple of summary report items
            _tuple = summary_levels[key]
        except (NameError, KeyError, AttributeError):
            # for some reason we could not obtain the summary report items from
            # the summary level config, so try to obtain a list of all known
            # summary report items from the summary report config
            try:
                # get the list of dicts that define all our known summary
                # items
                _summary_list = service_config.get('report', {}).get('summary', [])
                # now extract just the keys, this results in a list of know
                # summary items
                _fields = [k.keys() for k in _summary_list]
                # and convert our list to a tuple
                _tuple = tuple(_fields)
            except (KeyError, AttributeError):
                # if we could not get the list of all known summary items there
                # is nothing more we can do, just return any empty tuple
                pass
        # save a tuple of summary fields we will report
        self.summary_fields = _tuple
        # save the logwatch level of detail to be used
        self.detail = detail

        # create a dict to hold our results
        self.results = {}

        # construct a dict of compiled regex we understand
        # first, initialise a dict to hold the compiled regex
        self.regexs = {}
        # populate the compiled 'sum' res
        if 'sum' in self.ingest_config:
            # add a placeholder for 'sum' results
            self.results['sum'] = {}
            # create a dict to hold the compiled res
            self.regexs['sum'] = {}
            # iterate over our 'sum' config compiling res and
            # initialising counts
            for var, filter_str in self.ingest_config['sum'].items():
                # compile the re and save it
                self.regexs['sum'][var] = re.compile(filter_str)
                # initialise the corresponding count
                self.results['sum'][var] = 0
        # populate the compiled 'itemised' res
        if 'itemised' in self.ingest_config:
            # add a placeholder for 'sum' results
            self.results['itemised'] = {}
            # create a dict to hold the compiled res
            self.regexs['itemised'] = {}
            # add any regexs in our 'itemised' stanza
            self.add_filters(self.ingest_config['itemised'],
                             self.regexs['itemised'])

    @property
    def ingest_config(self):
        """My ingest config."""

        return self.service_config.get('ingest', {})

    @property
    def report_config(self):
        """My report config."""

        return self.service_config.get('report', {})

    def add_filters(self, stanza, results_dict):
        """Recursively add compiled regex filters to a dict."""

        for keyword, value in stanza.items():
            if hasattr(value, 'items'):
                # we have another section, call ourselves
                if keyword not in results_dict:
                    results_dict[keyword] = {}
                self.add_filters(value, results_dict[keyword])
            else:
                # we have a keyword = value pair, just compile the regex and save
                results_dict[keyword] = re.compile(value)

    def ingest_line(self, line):
        """Process a log entry line.

        Ingest a log entry line looking for a match. If a match is found
        extract and save the relevant info and return True, if no match is
        found return False.
        """

        # do we have any 'sum' regex's
        if 'sum' in self.regexs:
            # we have some regexs, so iterate over them
            for var, comp_regex in self.regexs['sum'].items():
                # now check if the regex finds a match, remember that 'sum'
                # regex's return a value
                z = comp_regex.search(line)
                if z:
                    # match found, so add found value to the relevant result
                    self.results['sum'][var] += int(z.groups()[0])
                    # since we have a match we can stop looking and return
                    return True
        # do we have any 'itemised' regex's
        if 'itemised' in self.regexs:
            # we have some 'itemised' regexs, so iterate over the sections
            for section_name, section_content in self.regexs['itemised'].items():
                # iterate over the items in each section
                if section_name not in self.results['itemised']:
                    self.results['itemised'][section_name] = {}
                our_results = self.results['itemised'][section_name]
                for regex_name, regex in section_content.items():
                    # do we have a key = value (compiled regex) pair or another
                    # dict
                    if not hasattr(regex, 'items'):
                        # it's a key = value (compiled regex) pair so just execute
                        # the regex and store the results if applicable
                        _match = regex.search(line)
                        if _match:
                            if len(_match.groups()) == 0:
                                if regex_name not in our_results:
                                    our_results[regex_name] = 1
                                else:
                                    our_results[regex_name] += 1
                            else:
                                if regex_name not in our_results:
                                    our_results[regex_name] = [_match.groups(), ]
                                else:
                                    our_results[regex_name] += [_match.groups(), ]
                            return True
                    else:
                        # we have a section, we only recognise an 'errors' section
                        if regex_name == 'errors':
                            if regex_name not in our_results:
                                our_results[regex_name] = {}
                            for sect_regex_name, sect_regex in regex.items():
                                if not hasattr(sect_regex, 'items'):
                                    # it's a key = value (compiled regex) pair
                                    _match = sect_regex.search(line)
                                    if _match:
                                        if sect_regex_name in our_results[regex_name]:
                                            our_results[regex_name][sect_regex_name] += 1
                                        else:
                                            our_results[regex_name][sect_regex_name] = 1
                                        if 'lines' in our_results[regex_name]:
                                            our_results[regex_name]['lines'].append(line)
                                        else:
                                            our_results[regex_name]['lines'] = [line]
                                        return True
        # if we made it here we found no matches so return False
        return False

    def ingest_itemised(self, line, key, ):
        """Ingest an itemised regex."""

        # TODO. Does this method need to be defined?
        pass

    def generate_summary_report(self, is_empty, detail=0):
        """Generate our contribution to the summary report."""

        # get the summary config from our report config
        summary_report_config = self.report_config.get('summary', [])
        # do we have any summary requirements
        if len(summary_report_config) > 0:
            # TODO. Do we really encounter any dicts? Should just be a list of dicts.
#            # do we have a dict or a list?
#            if hasattr(summary_report_config, 'items'):
#                # its a dict
#                for var, label in summary_report_config.items():
#                    # if we have content for this item print it
#                    result = self.get_result(var, self.results)
#                    if result is not None and result > 0:
#                        if is_empty:
#                            print("Summary counts:")
#                            is_empty = False
#                        print("  %-45s %6d" % (label, result))
#            else:
#                # it's a list
            # iterate over each summary report item
            for summary_item_dict in summary_report_config:
                for var, label in summary_item_dict.items():
                    if var not in self.summary_fields:
                        continue
                    # if we have content for this item print it
                    result = self.get_result(var, self.results)
                    if result is not None and result > 0:
                        if is_empty:
                            print("Summary counts:")
                            is_empty = False
                        print("  %-45s %6d" % (label, result))
        return is_empty

    def generate_itemised_report(self, detail=0):
        """Generate any itemised reports I know about."""

        # TODO. check spacing particularly if no itemised report items
        if detail >= 5:
            # get my itemised report config
            itemised_report_config = self.report_config.get('itemised', [])
            # do we have any itemised report items
            if len(itemised_report_config) > 0:
                for itemised_item_config in itemised_report_config:
                    for item_name, item_config in itemised_item_config.items():
                        # do we have a specialist method to call for this section
                        _method_name = ''.join(('generate_', item_name, '_itemised_report'))
                        if hasattr(self, _method_name):
                            # we do so call it
                            getattr(self, _method_name)(item_config,
                                                        detail=detail)
                        else:
                            self.generate_generic_itemised_report(item_config,
                                                                  item_name,
                                                                  detail=detail)

    def generate_generic_itemised_report(self, generic_report_config, generic_name, detail=0):
        """Generate a generic itemised report."""

        _is_empty = True
        # first do the 'items'
        # get the 'items' config
        items_report_config = generic_report_config.get('items')
        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    # TODO. Need cover for cases where 'sum' or 'itemised' is not in self.results
                    if 'itemised' in self.results and self.results['itemised'].get(generic_name) is not None:
                        _results = self.results['itemised'][generic_name].get(item)
                        if _results is None:
                            _results = self.get_result(item, self.results)
                            if _results is None:
                                continue
                    else:
                        _results = self.get_result(item, self.results)
                        if _results is None:
                            continue
                    if isinstance(_results, list):
                        # we have a list, we don't know what to do with lists (we
                        # are only generic) so pass
                        pass
                    else:
                        # we have a number, so it's a simple label: number
                        # we have some 'item' results
                        if _is_empty:
                            print()
                            print("%s:" % generic_report_config.get('label', item))
                            _is_empty = False
                        print("    %-43s %6d" % (data, _results))
        # now do the errors if the required detail is sufficiently high
        if detail >= 8 and 'itemised' in self.results:
            self.generate_itemised_errors_report(generic_report_config,
                                                 self.results['itemised'].get(generic_name),
                                                 _is_empty)

    @staticmethod
    def generate_itemised_errors_report(parent_report_config, parent_results, is_parent_empty):
        """Generate the 'Errors' component of an itemised report."""

        is_errors_empty = True
        errors_report_config = parent_report_config.get("errors")
        if errors_report_config:
            # and do we have any results to report
            if parent_results is not None and len(parent_results.get('errors', {})) > 0:
                # we have some error results
                if is_parent_empty:
                    print()
                    # TODO. Need to obtain a sensible default for 'label'
                    print("%s:" % parent_report_config.get('label'))
                    is_parent_empty = False
                if is_errors_empty:
                    print("  %s:" % errors_report_config.get('label', 'Error summary'))
                    is_errors_empty = False
                errors_items_config = errors_report_config.get('items', {})
                for error_item_config in errors_items_config:
                    for item, data in error_item_config.items():
                        if parent_results['errors'].get(item) is not None:
                            print("    %-43s %6d" % (data, parent_results['errors'].get(item)))
                # now list any accumulated error lines
                if parent_results['errors'].get('lines') is not None:
                    # now print the error lines, fist a blank line for formatting
                    print("    %s:" % 'Error lines')
                    for error_line in parent_results['errors']['lines']:
                        print("      %-111s" % (error_line.rstrip(),))

    def generate_additional_report(self, detail=0):
        """Generate any additional report output specific to this filter."""

        pass

    def get_result(self, field_name, results):
        """Obtain a result given a result field name.

        Recursively process the results dict looking for field_name. If found
        return the value, if not found return None.
        """

        # is field_name in this result level
        if field_name in results:
            # it is so return the value
            return results[field_name]
        # it is not in this result level so iterate over all our results at
        # this level looking for lower level results
        for val in results.values():
            # is this result value a dict, if so recursively call our self to
            # look for the field we are seeking
            if hasattr(val, 'items'):
                rec_result = self.get_result(field_name, val)
                # a result of None means the field we seek was not found, so
                # only return the result if it was not None
                if rec_result is not None:
                    return rec_result
        # if we made it here we could not find the field concerned so return None
        return None


class WeeWXLogwatchProcessor(LogwatchProcessor):
    """Class to process core WeeWX log files.

    This class knows how to ingest and report on WeeWX log lines generated by
    the core WeeWX code. It does not know how to ingest or report on log lines
    generated by WeeWX extensions, add-ons or other custom code. A separate
    LogWatchProcessor based object should be defined and invoked to process
    such lines.
    """


    def __init__(self, filter_config_dict, summary_levels, detail=0):
        # initialize my base class
        super(WeeWXLogwatchProcessor, self).__init__(filter_config_dict,
                                                     summary_levels,
                                                     detail)

        # Whilst the filtering of logs for clock error data is simple, the
        # subsequent reporting is complex so clock error processing is handled
        # separately and not via the WeeWX logwatch config. Compile and save
        # the necessary regex.
        self.regexs['clock'] = re.compile("engine: Clock error is ([0-9,.-]+)")

    def ingest_line(self, line):
        """Process a log entry line.

        As well as doing the standard matching we also need to look for clock
        related lines. Call our parent's ingest_line, capturing the result and
        if necessary then checking for a 'clock match'. Return the appropriate
        True/False result depending on whether we had a match or not.
        """

        # call our parent's ingest_line method catching the result
        _match = super(WeeWXLogwatchProcessor, self).ingest_line(line)
        # did we find a match?
        if not _match:
            # There was no match so look for a 'clock match'. Our result will
            # be whether ot not we found a 'clock match'.
            return self.clock(line)
        else:
            # our parent did find a match so return its result
            return _match

    def clock(self, line):
        """Process clock log lines"""

        _match = self.regexs['clock'].search(line)
        if _match:
            _result = float(_match.groups()[0])
            if 'clocksum' in self.results:
                self.results['clocksum'] += _result
                if _result < self.results['clockmin']:
                    self.results['clockmin'] = _result
                if _result > self.results['clockmax']:
                    self.results['clockmax'] = _result
                self.results['clockcount'] += 1
            else:
                self.results['clocksum'] = _result
                self.results['clockmin'] = 0
                self.results['clockmax'] = 0
                self.results['clockcount'] = 1
            return True
        return False

    def generate_summary_report(self, is_empty, detail=0):
        """Generate my portion of the summary report"""

        # TODO. Check clock operation with aurora, following does not seem right
        # Average station clock skew: 3.040
        # min: 0.000 max: 0.000 samples: 1

        # first do the clock if we have clock data
        if 'clockcount' in self.results and self.results['clockcount'] > 0:
            # calculate the average clock skew
            clock_skew = self.results['clocksum'] / self.results['clockcount']
            # print the results
            print("Average station clock skew: %.3f" % clock_skew)
            print("  min: %.3f max: %.3f samples: %d" % (self.results['clockmin'],
                                                         self.results['clockmax'],
                                                         self.results['clockcount']))
            print()

        # get the summary config from our report config
        summary_report_config = self.report_config.get('summary', [])
        # do we have any summary requirements
        if len(summary_report_config) > 0:
            # iterate over each summary report item
            for summary_item_dict in summary_report_config:
                for var, label in summary_item_dict.items():
                    if var not in self.summary_fields:
                        continue
                    # if we have content for this item print it
                    result = self.get_result(var, self.results)
                    # TODO. Is this try..except necessary or debugging only
                    try:
                        if result is not None and result > 0:
                            if is_empty:
                                print("Summary counts:")
                                is_empty = False
                            print("  %-45s %6d" % (label, result))
                    except TypeError:
                        print("result=%s" % (result,))
        return is_empty

    def generate_restx_itemised_report(self, restx_report_config, detail=0):
        """Generate the restx itemised report.

        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    # TODO. Need cover for cases where 'sum' or 'itemised' is not in self.results
                    if 'itemised' in self.results and self.results['itemised'].get(generic_name) is not None:
                        _results = self.results['itemised'][generic_name].get(item)



        """

        _is_empty = True
        # first do the 'items'
        # get the 'items' config
        items_report_config = restx_report_config.get('items')
        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    if self.results['itemised'].get('restx') is not None:
                        _results = self.results['itemised']['restx'].get(item)
                        if _results is not None and len(_results) > 0:
                            # we have some 'item' results
                            if _is_empty:
                                print()
                                print("%s:" % restx_report_config.get('label', item))
                                _is_empty = False
                            print("  %s:" % data)
                            _services = [z[0] for z in _results]
                            _unique_services = set(_services)
                            _res = {a: _services.count(a) for a in _unique_services}
                            for service, count in _res.items():
                                print("    %-43s %6d" % (service, count))
        # now do the errors if the required detail is sufficiently high
        if detail >= 8:
            self.generate_itemised_errors_report(restx_report_config,
                                                 self.results['itemised'].get('restx'),
                                                 _is_empty)

    def generate_image_generator_itemised_report(self, image_generator_report_config, detail=0):
        """Generate the image_generator itemised report."""

        _is_empty = True
        # first do the 'items'
        # get the 'items' config
        items_report_config = image_generator_report_config.get('items')
        # do we have any items?
        if items_report_config and len(items_report_config) > 0:
            # iterate over the entries
            for item_config in items_report_config:
                for item, data in item_config.items():
                    if self.results['itemised'].get('image_generator') is not None:
                        _results = self.results['itemised']['image_generator'].get(item)
                        if _results is None:
                            _results = self.get_result(item, self.results)
                            if _results is None:
                                continue
                    else:
                        _results = self.get_result(item, self.results)
                        if _results is None:
                            continue
                    if _results is not None:
                        # we have some 'item' results
                        if _is_empty:
                            print()
                            print("%s:" % image_generator_report_config.get('label', item))
                            _is_empty = False
                        print("    %-43s %6d" % (data, _results))
        # now do the errors if the required detail is sufficiently high
        if detail >= 8:
            self.generate_itemised_errors_report(image_generator_report_config,
                                                 self.results['itemised'].get('image_generator'),
                                                 _is_empty)

    def process_section(self, regexs, line, section, results):
        """"""

        for keyword, value in section.items():
            if not hasattr(value, 'items'):
                # it's a key = value (compiled regex) pair
                if keyword in regexs:
                    _match = regexs[keyword].search(line)
                    if _match:
                        if keyword in results:
                            results[keyword] += 1
                        else:
                            results[keyword] = 1
                        if 'lines' in results:
                            results['lines'].append(line)
                        else:
                            results['lines'] = [line]
                        return True
            else:
                # it's a section so call our self
                if keyword not in results:
                    results[keyword] = {}
                return self.process_section(regexs.get(keyword, {}), line, value, results[keyword])
        return False


description = """Analyse WeeWX logs and generate a logwatch report."""

usage = """weewx --help
       weewx --version
       weewx --logwatch-config=LOGWATCH_CONFIG_FILE
       weewx --source=LOG_SOURCE_FILE
       weewx --detail=LOGWATCH_DETAIL_LEVEL
"""

epilog = """This script will analyse WeeWX log entries and generate the WeeWX 
            portion of a logwatch system report."""


def main():
    """The main routine that kicks everything off.

    Can be run directly like a standard WeeWX utility or can be called as a
    logwatch module. If called with no options it is assumed that logwatch has
    made the call. Otherwise, the options are processed and executed as
    applicable.
    """

    # lookup dict for converting report detail level descriptors to an integer
    # in the range 0-10 incl
    detail_lookup = {'low': 0, 'medium': 5, 'high': 10}

    # create a command line parser
    parser = optparse.OptionParser(description=description,
                                   usage=usage,
                                   epilog=epilog)

    # add the various options
    parser.add_option("--logwatch-config", dest="logwatch_config_path", type=str,
                      metavar="LOGWATCH_CONFIG_FILE",
                      help="Use WeeWX logwatch configuration file LOGWATCH_CONFIG_FILE.")
    parser.add_option("--log-source", dest="log_source", type=str,
                      metavar="LOG_SOURCE_FILE",
                      help="Read log entries from LOG_SOURCE_FILE.")
    # Would normally set a default value of 0 for detail_level but that
    # complicates determining whether logwatch called us or whether we were
    # invoked directly. Omit default and do some extract processing later to
    # work out a default for when we are invoked directly.
    parser.add_option("--detail", dest="detail_level", type=str,
                      metavar="LOGWATCH_DETAIL_LEVEL",
                      help="Logwatch detail level. Positive integer from 0 (least detail) "
                           "to 10 (most detail) or low, medium or high.")
    parser.add_option("--version", dest="version", action="store_true",
                      help="Display WeeWX logwatch script version number.")

    # now parse the command line
    (options, args) = parser.parse_args()

    # Check if we have been called by logwatch or directly. The difference will
    # be in the command line options.
    if all([v is None for v in options.__dict__.values()]) and len(args) == 0:
        # We have no options or args so logwatch must have called us. We will
        # be processing whatever log entries logwatch sends us.

        # first obtain the detail level we are to use, this will have been set
        # by the logwatch --detail command line option, but we can find it in
        # the environment variable 'LOGWATCH_DETAIL_LEVEL'
        logwatch_detail = int(os.environ.get('LOGWATCH_DETAIL_LEVEL', 0))
        # now obtain a WeeWXLogwatchEngine object
        logwatch_controller = WeeWXLogwatchEngine(detail=logwatch_detail)
    else:
        # We have one or more command line options, so we are being called
        # directly. Process the options as required.

        # --version. Display our version number then exit.
        if options.version:
            print("WeeWX logwatch script version: %s" % WEEWX_LOGWATCH_VERSION)
            exit(0)

        # if we made it here we must be going to process some logs

        # first get the detail level to be used, we want both the numeric
        # equivalent and a string version
        try:
            logwatch_detail = int(options.detail_level)
            detail_str = options.detail_level
        except (TypeError, ValueError):
            # can't convert the detail_level option to an integer, perhaps it
            # is 'low', 'medium' or 'high' or was not specified
            # first check if it was not specified (ie None), if it is None
            # force the detail level to 0 (low)
            if options.detail_level is None:
                logwatch_detail = 0
                detail_str = "LOW (0)"
            else:
                # otherwise we have a string, check if it is one of our known
                # strings by looking up our detail level dict
                logwatch_detail = detail_lookup.get(options.detail_level.lower())
                if logwatch_detail is not None:
                    # we found a known string so construct a suitable string
                    # representation
                    detail_str = "%s (%d)" % (options.detail_level.upper(),
                                              logwatch_detail)
                else:
                    # we didn't find a known string so default to 0 (low)
                    logwatch_detail = 0
                    detail_str = "LOW (0)"
        # say what we are doing...and with what
        print("Running WeeWX logwatch script directly...")
        if options.logwatch_config_path is None:
            print("  using the default WeeWX logwatch config")
        else:
            print("  using WeeWX logwatch config file: %s" % options.logwatch_config_path)
        print("  log source is: %s" % options.log_source)
        print("  detail level is: %s" % detail_str)
        print()
        # obtain a WeeWXLogwatchEngine object
        logwatch_controller = WeeWXLogwatchEngine(log_source=options.log_source,
                                                  detail=logwatch_detail)
    # now call the run() method of our LogwatchController object
    logwatch_controller.run()


# execute our main code
if __name__ == "__main__":
    main()
